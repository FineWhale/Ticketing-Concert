{"ast":null,"code":"import { merge } from \"@rc-component/util/es/utils/set\";\nimport { mergeWith } from '@rc-component/util';\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { HOOK_MARK } from \"../FieldContext\";\nimport { allPromiseFinish } from \"../utils/asyncUtil\";\nimport { defaultValidateMessages } from \"../utils/messages\";\nimport NameMap from \"../utils/NameMap\";\nimport { cloneByNamePathList, containsNamePath, getNamePath, getValue, matchNamePath, setValue } from \"../utils/valueUtil\";\nimport WatcherCenter from \"./useNotifyWatch\";\nexport class FormStore {\n  formHooked = false;\n  forceRootUpdate;\n  subscribable = true;\n  store = {};\n  fieldEntities = [];\n  initialValues = {};\n  callbacks = {};\n  validateMessages = null;\n  preserve = null;\n  lastValidatePromise = null;\n  watcherCenter = new WatcherCenter(this);\n  constructor(forceRootUpdate) {\n    this.forceRootUpdate = forceRootUpdate;\n  }\n  getForm = () => ({\n    getFieldValue: this.getFieldValue,\n    getFieldsValue: this.getFieldsValue,\n    getFieldError: this.getFieldError,\n    getFieldWarning: this.getFieldWarning,\n    getFieldsError: this.getFieldsError,\n    isFieldsTouched: this.isFieldsTouched,\n    isFieldTouched: this.isFieldTouched,\n    isFieldValidating: this.isFieldValidating,\n    isFieldsValidating: this.isFieldsValidating,\n    resetFields: this.resetFields,\n    setFields: this.setFields,\n    setFieldValue: this.setFieldValue,\n    setFieldsValue: this.setFieldsValue,\n    validateFields: this.validateFields,\n    submit: this.submit,\n    _init: true,\n    getInternalHooks: this.getInternalHooks\n  });\n\n  // ======================== Internal Hooks ========================\n  getInternalHooks = key => {\n    if (key === HOOK_MARK) {\n      this.formHooked = true;\n      return {\n        dispatch: this.dispatch,\n        initEntityValue: this.initEntityValue,\n        registerField: this.registerField,\n        useSubscribe: this.useSubscribe,\n        setInitialValues: this.setInitialValues,\n        destroyForm: this.destroyForm,\n        setCallbacks: this.setCallbacks,\n        setValidateMessages: this.setValidateMessages,\n        getFields: this.getFields,\n        setPreserve: this.setPreserve,\n        getInitialValue: this.getInitialValue,\n        registerWatch: this.registerWatch\n      };\n    }\n    warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\n    return null;\n  };\n  useSubscribe = subscribable => {\n    this.subscribable = subscribable;\n  };\n\n  /**\n   * Record prev Form unmount fieldEntities which config preserve false.\n   * This need to be refill with initialValues instead of store value.\n   */\n  prevWithoutPreserves = null;\n\n  /**\n   * First time `setInitialValues` should update store with initial value\n   */\n  setInitialValues = (initialValues, init) => {\n    this.initialValues = initialValues || {};\n    if (init) {\n      let nextStore = merge(initialValues, this.store);\n\n      // We will take consider prev form unmount fields.\n      // When the field is not `preserve`, we need fill this with initialValues instead of store.\n      // eslint-disable-next-line array-callback-return\n      this.prevWithoutPreserves?.map(({\n        key: namePath\n      }) => {\n        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\n      });\n      this.prevWithoutPreserves = null;\n      this.updateStore(nextStore);\n    }\n  };\n  destroyForm = clearOnDestroy => {\n    if (clearOnDestroy) {\n      // destroy form reset store\n      this.updateStore({});\n    } else {\n      // Fill preserve fields\n      const prevWithoutPreserves = new NameMap();\n      this.getFieldEntities(true).forEach(entity => {\n        if (!this.isMergedPreserve(entity.isPreserve())) {\n          prevWithoutPreserves.set(entity.getNamePath(), true);\n        }\n      });\n      this.prevWithoutPreserves = prevWithoutPreserves;\n    }\n  };\n  getInitialValue = namePath => {\n    const initValue = getValue(this.initialValues, namePath);\n\n    // Not cloneDeep when without `namePath`\n    return namePath.length ? merge(initValue) : initValue;\n  };\n  setCallbacks = callbacks => {\n    this.callbacks = callbacks;\n  };\n  setValidateMessages = validateMessages => {\n    this.validateMessages = validateMessages;\n  };\n  setPreserve = preserve => {\n    this.preserve = preserve;\n  };\n\n  // ============================= Watch ============================\n  registerWatch = callback => {\n    return this.watcherCenter.register(callback);\n  };\n  notifyWatch = (namePath = []) => {\n    this.watcherCenter.notify(namePath);\n  };\n\n  // ========================== Dev Warning =========================\n  timeoutId = null;\n  warningUnhooked = () => {\n    if (process.env.NODE_ENV !== 'production' && !this.timeoutId && typeof window !== 'undefined') {\n      this.timeoutId = setTimeout(() => {\n        this.timeoutId = null;\n        if (!this.formHooked) {\n          warning(false, 'Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?');\n        }\n      });\n    }\n  };\n\n  // ============================ Store =============================\n  updateStore = nextStore => {\n    this.store = nextStore;\n  };\n\n  // ============================ Fields ============================\n  /**\n   * Get registered field entities.\n   * @param pure Only return field which has a `name`. Default: false\n   */\n  getFieldEntities = (pure = false) => {\n    if (!pure) {\n      return this.fieldEntities;\n    }\n    return this.fieldEntities.filter(field => field.getNamePath().length);\n  };\n\n  /**\n   * Get a map of registered field entities with their name path as the key.\n   * @param pure Only include fields which have a `name`. Default: false\n   * @returns A NameMap containing field entities indexed by their name paths\n   */\n  getFieldsMap = (pure = false) => {\n    const cache = new NameMap();\n    this.getFieldEntities(pure).forEach(field => {\n      const namePath = field.getNamePath();\n      cache.set(namePath, field);\n    });\n    return cache;\n  };\n\n  /**\n   * Get field entities based on a list of name paths.\n   * @param nameList - Array of name paths to search for. If not provided, returns all field entities with names.\n   * @param includesSubNamePath - Whether to include fields that have the given name path as a prefix.\n   */\n  getFieldEntitiesForNamePathList = (nameList, includesSubNamePath = false) => {\n    if (!nameList) {\n      return this.getFieldEntities(true);\n    }\n    const cache = this.getFieldsMap(true);\n    if (!includesSubNamePath) {\n      return nameList.map(name => {\n        const namePath = getNamePath(name);\n        return cache.get(namePath) || {\n          INVALIDATE_NAME_PATH: getNamePath(name)\n        };\n      });\n    }\n    return nameList.flatMap(name => {\n      const namePath = getNamePath(name);\n      const fields = cache.getAsPrefix(namePath);\n      if (fields.length) {\n        return fields;\n      }\n      return [{\n        INVALIDATE_NAME_PATH: namePath\n      }];\n    });\n  };\n  getFieldsValue = (nameList, filterFunc) => {\n    this.warningUnhooked();\n\n    // Fill args\n    let mergedNameList;\n    let mergedFilterFunc;\n    if (nameList === true || Array.isArray(nameList)) {\n      mergedNameList = nameList;\n      mergedFilterFunc = filterFunc;\n    } else if (nameList && typeof nameList === 'object') {\n      mergedFilterFunc = nameList.filter;\n    }\n    if (mergedNameList === true && !mergedFilterFunc) {\n      return this.store;\n    }\n    const fieldEntities = this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null, true);\n    const filteredNameList = [];\n    const listNamePaths = [];\n    fieldEntities.forEach(entity => {\n      const namePath = entity.INVALIDATE_NAME_PATH || entity.getNamePath();\n\n      // Ignore when it's a list item and not specific the namePath,\n      // since parent field is already take in count\n      if (entity.isList?.()) {\n        listNamePaths.push(namePath);\n        return;\n      }\n      if (!mergedFilterFunc) {\n        filteredNameList.push(namePath);\n      } else {\n        const meta = 'getMeta' in entity ? entity.getMeta() : null;\n        if (mergedFilterFunc(meta)) {\n          filteredNameList.push(namePath);\n        }\n      }\n    });\n    let mergedValues = cloneByNamePathList(this.store, filteredNameList.map(getNamePath));\n\n    // We need fill the list as [] if Form.List is empty\n    listNamePaths.forEach(namePath => {\n      if (!getValue(mergedValues, namePath)) {\n        mergedValues = setValue(mergedValues, namePath, []);\n      }\n    });\n    return mergedValues;\n  };\n  getFieldValue = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    return getValue(this.store, namePath);\n  };\n  getFieldsError = nameList => {\n    this.warningUnhooked();\n    const fieldEntities = this.getFieldEntitiesForNamePathList(nameList);\n    return fieldEntities.map((entity, index) => {\n      if (entity && !entity.INVALIDATE_NAME_PATH) {\n        return {\n          name: entity.getNamePath(),\n          errors: entity.getErrors(),\n          warnings: entity.getWarnings()\n        };\n      }\n      return {\n        name: getNamePath(nameList[index]),\n        errors: [],\n        warnings: []\n      };\n    });\n  };\n  getFieldError = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    const fieldError = this.getFieldsError([namePath])[0];\n    return fieldError.errors;\n  };\n  getFieldWarning = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    const fieldError = this.getFieldsError([namePath])[0];\n    return fieldError.warnings;\n  };\n  isFieldsTouched = (...args) => {\n    this.warningUnhooked();\n    const [arg0, arg1] = args;\n    let namePathList;\n    let isAllFieldsTouched = false;\n    if (args.length === 0) {\n      namePathList = null;\n    } else if (args.length === 1) {\n      if (Array.isArray(arg0)) {\n        namePathList = arg0.map(getNamePath);\n        isAllFieldsTouched = false;\n      } else {\n        namePathList = null;\n        isAllFieldsTouched = arg0;\n      }\n    } else {\n      namePathList = arg0.map(getNamePath);\n      isAllFieldsTouched = arg1;\n    }\n    const fieldEntities = this.getFieldEntities(true);\n    const isFieldTouched = field => field.isFieldTouched();\n\n    // ===== Will get fully compare when not config namePathList =====\n    if (!namePathList) {\n      return isAllFieldsTouched ? fieldEntities.every(entity => isFieldTouched(entity) || entity.isList()) : fieldEntities.some(isFieldTouched);\n    }\n\n    // Generate a nest tree for validate\n    const map = new NameMap();\n    namePathList.forEach(shortNamePath => {\n      map.set(shortNamePath, []);\n    });\n    fieldEntities.forEach(field => {\n      const fieldNamePath = field.getNamePath();\n\n      // Find matched entity and put into list\n      namePathList.forEach(shortNamePath => {\n        if (shortNamePath.every((nameUnit, i) => fieldNamePath[i] === nameUnit)) {\n          map.update(shortNamePath, list => [...list, field]);\n        }\n      });\n    });\n\n    // Check if NameMap value is touched\n    const isNamePathListTouched = entities => entities.some(isFieldTouched);\n    const namePathListEntities = map.map(({\n      value\n    }) => value);\n    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\n  };\n  isFieldTouched = name => {\n    this.warningUnhooked();\n    return this.isFieldsTouched([name]);\n  };\n  isFieldsValidating = nameList => {\n    this.warningUnhooked();\n    const fieldEntities = this.getFieldEntities();\n    if (!nameList) {\n      return fieldEntities.some(testField => testField.isFieldValidating());\n    }\n    const namePathList = nameList.map(getNamePath);\n    return fieldEntities.some(testField => {\n      const fieldNamePath = testField.getNamePath();\n      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\n    });\n  };\n  isFieldValidating = name => {\n    this.warningUnhooked();\n    return this.isFieldsValidating([name]);\n  };\n\n  /**\n   * Reset Field with field `initialValue` prop.\n   * Can pass `entities` or `namePathList` or just nothing.\n   */\n  resetWithFieldInitialValue = (info = {}) => {\n    // Create cache\n    const cache = new NameMap();\n    const fieldEntities = this.getFieldEntities(true);\n    fieldEntities.forEach(field => {\n      const {\n        initialValue\n      } = field.props;\n      const namePath = field.getNamePath();\n\n      // Record only if has `initialValue`\n      if (initialValue !== undefined) {\n        const records = cache.get(namePath) || new Set();\n        records.add({\n          entity: field,\n          value: initialValue\n        });\n        cache.set(namePath, records);\n      }\n    });\n\n    // Reset\n    const resetWithFields = entities => {\n      entities.forEach(field => {\n        const {\n          initialValue\n        } = field.props;\n        if (initialValue !== undefined) {\n          const namePath = field.getNamePath();\n          const formInitialValue = this.getInitialValue(namePath);\n          if (formInitialValue !== undefined) {\n            // Warning if conflict with form initialValues and do not modify value\n            warning(false, `Form already set 'initialValues' with path '${namePath.join('.')}'. Field can not overwrite it.`);\n          } else {\n            const records = cache.get(namePath);\n            if (records && records.size > 1) {\n              // Warning if multiple field set `initialValue`and do not modify value\n              warning(false, `Multiple Field with path '${namePath.join('.')}' set 'initialValue'. Can not decide which one to pick.`);\n            } else if (records) {\n              const originValue = this.getFieldValue(namePath);\n              const isListField = field.isListField();\n\n              // Set `initialValue`\n              if (!isListField && (!info.skipExist || originValue === undefined)) {\n                this.updateStore(setValue(this.store, namePath, [...records][0].value));\n              }\n            }\n          }\n        }\n      });\n    };\n    let requiredFieldEntities;\n    if (info.entities) {\n      requiredFieldEntities = info.entities;\n    } else if (info.namePathList) {\n      requiredFieldEntities = [];\n      info.namePathList.forEach(namePath => {\n        const records = cache.get(namePath);\n        if (records) {\n          requiredFieldEntities.push(...[...records].map(r => r.entity));\n        }\n      });\n    } else {\n      requiredFieldEntities = fieldEntities;\n    }\n    resetWithFields(requiredFieldEntities);\n  };\n  resetFields = nameList => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    if (!nameList) {\n      this.updateStore(merge(this.initialValues));\n      this.resetWithFieldInitialValue();\n      this.notifyObservers(prevStore, null, {\n        type: 'reset'\n      });\n      this.notifyWatch();\n      return;\n    }\n\n    // Reset by `nameList`\n    const namePathList = nameList.map(getNamePath);\n    namePathList.forEach(namePath => {\n      const initialValue = this.getInitialValue(namePath);\n      this.updateStore(setValue(this.store, namePath, initialValue));\n    });\n    this.resetWithFieldInitialValue({\n      namePathList\n    });\n    this.notifyObservers(prevStore, namePathList, {\n      type: 'reset'\n    });\n    this.notifyWatch(namePathList);\n  };\n  setFields = fields => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    const namePathList = [];\n    fields.forEach(fieldData => {\n      const {\n        name,\n        ...data\n      } = fieldData;\n      const namePath = getNamePath(name);\n      namePathList.push(namePath);\n\n      // Value\n      if ('value' in data) {\n        this.updateStore(setValue(this.store, namePath, data.value));\n      }\n      this.notifyObservers(prevStore, [namePath], {\n        type: 'setField',\n        data: fieldData\n      });\n    });\n    this.notifyWatch(namePathList);\n  };\n  getFields = () => {\n    const entities = this.getFieldEntities(true);\n    const fields = entities.map(field => {\n      const namePath = field.getNamePath();\n      const meta = field.getMeta();\n      const fieldData = {\n        ...meta,\n        name: namePath,\n        value: this.getFieldValue(namePath)\n      };\n      Object.defineProperty(fieldData, 'originRCField', {\n        value: true\n      });\n      return fieldData;\n    });\n    return fields;\n  };\n\n  // =========================== Observer ===========================\n  /**\n   * This only trigger when a field is on constructor to avoid we get initialValue too late\n   */\n  initEntityValue = entity => {\n    const {\n      initialValue\n    } = entity.props;\n    if (initialValue !== undefined) {\n      const namePath = entity.getNamePath();\n      const prevValue = getValue(this.store, namePath);\n      if (prevValue === undefined) {\n        this.updateStore(setValue(this.store, namePath, initialValue));\n      }\n    }\n  };\n  isMergedPreserve = fieldPreserve => {\n    const mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : this.preserve;\n    return mergedPreserve ?? true;\n  };\n  registerField = entity => {\n    this.fieldEntities.push(entity);\n    const namePath = entity.getNamePath();\n    this.notifyWatch([namePath]);\n\n    // Set initial values\n    if (entity.props.initialValue !== undefined) {\n      const prevStore = this.store;\n      this.resetWithFieldInitialValue({\n        entities: [entity],\n        skipExist: true\n      });\n      this.notifyObservers(prevStore, [entity.getNamePath()], {\n        type: 'valueUpdate',\n        source: 'internal'\n      });\n    }\n\n    // un-register field callback\n    return (isListField, preserve, subNamePath = []) => {\n      this.fieldEntities = this.fieldEntities.filter(item => item !== entity);\n\n      // Clean up store value if not preserve\n      if (!this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {\n        const defaultValue = isListField ? undefined : this.getInitialValue(namePath);\n        if (namePath.length && this.getFieldValue(namePath) !== defaultValue && this.fieldEntities.every(field =>\n        // Only reset when no namePath exist\n        !matchNamePath(field.getNamePath(), namePath))) {\n          const prevStore = this.store;\n          this.updateStore(setValue(prevStore, namePath, defaultValue, true));\n\n          // Notify that field is unmount\n          this.notifyObservers(prevStore, [namePath], {\n            type: 'remove'\n          });\n\n          // Dependencies update\n          this.triggerDependenciesUpdate(prevStore, namePath);\n        }\n      }\n      this.notifyWatch([namePath]);\n    };\n  };\n  dispatch = action => {\n    switch (action.type) {\n      case 'updateValue':\n        {\n          const {\n            namePath,\n            value\n          } = action;\n          this.updateValue(namePath, value);\n          break;\n        }\n      case 'validateField':\n        {\n          const {\n            namePath,\n            triggerName\n          } = action;\n          this.validateFields([namePath], {\n            triggerName\n          });\n          break;\n        }\n      default:\n      // Currently we don't have other action. Do nothing.\n    }\n  };\n  notifyObservers = (prevStore, namePathList, info) => {\n    if (this.subscribable) {\n      const mergedInfo = {\n        ...info,\n        store: this.getFieldsValue(true)\n      };\n      this.getFieldEntities().forEach(({\n        onStoreChange\n      }) => {\n        onStoreChange(prevStore, namePathList, mergedInfo);\n      });\n    } else {\n      this.forceRootUpdate();\n    }\n  };\n\n  /**\n   * Notify dependencies children with parent update\n   * We need delay to trigger validate in case Field is under render props\n   */\n  triggerDependenciesUpdate = (prevStore, namePath) => {\n    const childrenFields = this.getDependencyChildrenFields(namePath);\n    if (childrenFields.length) {\n      this.validateFields(childrenFields);\n    }\n    this.notifyObservers(prevStore, childrenFields, {\n      type: 'dependenciesUpdate',\n      relatedFields: [namePath, ...childrenFields]\n    });\n    return childrenFields;\n  };\n  updateValue = (name, value) => {\n    const namePath = getNamePath(name);\n    const prevStore = this.store;\n    this.updateStore(setValue(this.store, namePath, value));\n    this.notifyObservers(prevStore, [namePath], {\n      type: 'valueUpdate',\n      source: 'internal'\n    });\n    this.notifyWatch([namePath]);\n\n    // Dependencies update\n    const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);\n\n    // trigger callback function\n    const {\n      onValuesChange\n    } = this.callbacks;\n    if (onValuesChange) {\n      const fieldEntity = this.getFieldsMap(true).get(namePath);\n      const changedValues = cloneByNamePathList(this.store, [namePath]);\n      const allValues = this.getFieldsValue();\n      // Merge changedValues into allValues to ensure allValues contains the latest changes\n      const mergedAllValues = mergeWith([allValues, changedValues], {\n        // When value is array, it means trigger by Form.List which should replace directly\n        prepareArray: current => fieldEntity?.isList() ? [] : [...(current || [])]\n      });\n      onValuesChange(changedValues, mergedAllValues);\n    }\n    this.triggerOnFieldsChange([namePath, ...childrenFields]);\n  };\n\n  // Let all child Field get update.\n  setFieldsValue = store => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    if (store) {\n      const nextStore = merge(this.store, store);\n      this.updateStore(nextStore);\n    }\n    this.notifyObservers(prevStore, null, {\n      type: 'valueUpdate',\n      source: 'external'\n    });\n    this.notifyWatch();\n  };\n  setFieldValue = (name, value) => {\n    this.setFields([{\n      name,\n      value,\n      errors: [],\n      warnings: [],\n      touched: true\n    }]);\n  };\n  getDependencyChildrenFields = rootNamePath => {\n    const children = new Set();\n    const childrenFields = [];\n    const dependencies2fields = new NameMap();\n\n    /**\n     * Generate maps\n     * Can use cache to save perf if user report performance issue with this\n     */\n    this.getFieldEntities().forEach(field => {\n      const {\n        dependencies\n      } = field.props;\n      (dependencies || []).forEach(dependency => {\n        const dependencyNamePath = getNamePath(dependency);\n        dependencies2fields.update(dependencyNamePath, (fields = new Set()) => {\n          fields.add(field);\n          return fields;\n        });\n      });\n    });\n    const fillChildren = namePath => {\n      const fields = dependencies2fields.get(namePath) || new Set();\n      fields.forEach(field => {\n        if (!children.has(field)) {\n          children.add(field);\n          const fieldNamePath = field.getNamePath();\n          if (field.isFieldDirty() && fieldNamePath.length) {\n            childrenFields.push(fieldNamePath);\n            fillChildren(fieldNamePath);\n          }\n        }\n      });\n    };\n    fillChildren(rootNamePath);\n    return childrenFields;\n  };\n  triggerOnFieldsChange = (namePathList, filedErrors) => {\n    const {\n      onFieldsChange\n    } = this.callbacks;\n    if (onFieldsChange) {\n      const fields = this.getFields();\n\n      /**\n       * Fill errors since `fields` may be replaced by controlled fields\n       */\n      if (filedErrors) {\n        const cache = new NameMap();\n        filedErrors.forEach(({\n          name,\n          errors\n        }) => {\n          cache.set(name, errors);\n        });\n        fields.forEach(field => {\n          // eslint-disable-next-line no-param-reassign\n          field.errors = cache.get(field.name) || field.errors;\n        });\n      }\n      const changedFields = fields.filter(({\n        name: fieldName\n      }) => containsNamePath(namePathList, fieldName));\n      if (changedFields.length) {\n        onFieldsChange(changedFields, fields);\n      }\n    }\n  };\n\n  // =========================== Validate ===========================\n  validateFields = (arg1, arg2) => {\n    this.warningUnhooked();\n    let nameList;\n    let options;\n    if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {\n      nameList = arg1;\n      options = arg2;\n    } else {\n      options = arg1;\n    }\n    const provideNameList = !!nameList;\n    const namePathList = provideNameList ? nameList.map(getNamePath) : [];\n    // Same namePathList, but does not include Form.List name\n    const finalValueNamePathList = [...namePathList];\n\n    // Collect result in promise list\n    const promiseList = [];\n\n    // We temp save the path which need trigger for `onFieldsChange`\n    const TMP_SPLIT = String(Date.now());\n    const validateNamePathList = new Set();\n    const {\n      recursive,\n      dirty\n    } = options || {};\n    this.getFieldEntities(true).forEach(field => {\n      const fieldNamePath = field.getNamePath();\n\n      // Add field if not provide `nameList`\n      if (!provideNameList) {\n        if (\n        // If is field, pass directly\n        !field.isList() ||\n        // If is list, do not add if already exist sub field in the namePathList\n        !namePathList.some(name => matchNamePath(name, fieldNamePath, true))) {\n          finalValueNamePathList.push(fieldNamePath);\n        }\n        namePathList.push(fieldNamePath);\n      }\n\n      // Skip if without rule\n      if (!field.props.rules || !field.props.rules.length) {\n        return;\n      }\n\n      // Skip if only validate dirty field\n      if (dirty && !field.isFieldDirty()) {\n        return;\n      }\n      validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));\n\n      // Add field validate rule in to promise list\n      if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {\n        const promise = field.validateRules({\n          validateMessages: {\n            ...defaultValidateMessages,\n            ...this.validateMessages\n          },\n          ...options\n        });\n\n        // Wrap promise with field\n        promiseList.push(promise.then(() => ({\n          name: fieldNamePath,\n          errors: [],\n          warnings: []\n        })).catch(ruleErrors => {\n          const mergedErrors = [];\n          const mergedWarnings = [];\n          ruleErrors.forEach?.(({\n            rule: {\n              warningOnly\n            },\n            errors\n          }) => {\n            if (warningOnly) {\n              mergedWarnings.push(...errors);\n            } else {\n              mergedErrors.push(...errors);\n            }\n          });\n          if (mergedErrors.length) {\n            return Promise.reject({\n              name: fieldNamePath,\n              errors: mergedErrors,\n              warnings: mergedWarnings\n            });\n          }\n          return {\n            name: fieldNamePath,\n            errors: mergedErrors,\n            warnings: mergedWarnings\n          };\n        }));\n      }\n    });\n    const summaryPromise = allPromiseFinish(promiseList);\n    this.lastValidatePromise = summaryPromise;\n\n    // Notify fields with rule that validate has finished and need update\n    summaryPromise.catch(results => results).then(results => {\n      const resultNamePathList = results.map(({\n        name\n      }) => name);\n      this.notifyObservers(this.store, resultNamePathList, {\n        type: 'validateFinish'\n      });\n      this.triggerOnFieldsChange(resultNamePathList, results);\n    });\n    const returnPromise = summaryPromise.then(() => {\n      if (this.lastValidatePromise === summaryPromise) {\n        return Promise.resolve(this.getFieldsValue(finalValueNamePathList));\n      }\n      return Promise.reject([]);\n    }).catch(results => {\n      const errorList = results.filter(result => result && result.errors.length);\n      const errorMessage = errorList[0]?.errors?.[0];\n      return Promise.reject({\n        message: errorMessage,\n        values: this.getFieldsValue(namePathList),\n        errorFields: errorList,\n        outOfDate: this.lastValidatePromise !== summaryPromise\n      });\n    });\n\n    // Do not throw in console\n    returnPromise.catch(e => e);\n\n    // `validating` changed. Trigger `onFieldsChange`\n    const triggerNamePathList = namePathList.filter(namePath => validateNamePathList.has(namePath.join(TMP_SPLIT)));\n    this.triggerOnFieldsChange(triggerNamePathList);\n    return returnPromise;\n  };\n\n  // ============================ Submit ============================\n  submit = () => {\n    this.warningUnhooked();\n    this.validateFields().then(values => {\n      const {\n        onFinish\n      } = this.callbacks;\n      if (onFinish) {\n        try {\n          onFinish(values);\n        } catch (err) {\n          // Should print error if user `onFinish` callback failed\n          console.error(err);\n        }\n      }\n    }).catch(e => {\n      const {\n        onFinishFailed\n      } = this.callbacks;\n      if (onFinishFailed) {\n        onFinishFailed(e);\n      }\n    });\n  };\n}\nfunction useForm(form) {\n  const formRef = React.useRef(null);\n  const [, forceUpdate] = React.useState({});\n\n  // Create singleton FormStore\n  if (!formRef.current) {\n    if (form) {\n      formRef.current = form;\n    } else {\n      // Create a new FormStore if not provided\n      const forceReRender = () => {\n        forceUpdate({});\n      };\n      const formStore = new FormStore(forceReRender);\n      formRef.current = formStore.getForm();\n    }\n  }\n  return [formRef.current];\n}\nexport default useForm;","map":{"version":3,"names":["merge","mergeWith","warning","React","HOOK_MARK","allPromiseFinish","defaultValidateMessages","NameMap","cloneByNamePathList","containsNamePath","getNamePath","getValue","matchNamePath","setValue","WatcherCenter","FormStore","formHooked","forceRootUpdate","subscribable","store","fieldEntities","initialValues","callbacks","validateMessages","preserve","lastValidatePromise","watcherCenter","constructor","getForm","getFieldValue","getFieldsValue","getFieldError","getFieldWarning","getFieldsError","isFieldsTouched","isFieldTouched","isFieldValidating","isFieldsValidating","resetFields","setFields","setFieldValue","setFieldsValue","validateFields","submit","_init","getInternalHooks","key","dispatch","initEntityValue","registerField","useSubscribe","setInitialValues","destroyForm","setCallbacks","setValidateMessages","getFields","setPreserve","getInitialValue","registerWatch","prevWithoutPreserves","init","nextStore","map","namePath","updateStore","clearOnDestroy","getFieldEntities","forEach","entity","isMergedPreserve","isPreserve","set","initValue","length","callback","register","notifyWatch","notify","timeoutId","warningUnhooked","process","env","NODE_ENV","window","setTimeout","pure","filter","field","getFieldsMap","cache","getFieldEntitiesForNamePathList","nameList","includesSubNamePath","name","get","INVALIDATE_NAME_PATH","flatMap","fields","getAsPrefix","filterFunc","mergedNameList","mergedFilterFunc","Array","isArray","filteredNameList","listNamePaths","isList","push","meta","getMeta","mergedValues","index","errors","getErrors","warnings","getWarnings","fieldError","args","arg0","arg1","namePathList","isAllFieldsTouched","every","some","shortNamePath","fieldNamePath","nameUnit","i","update","list","isNamePathListTouched","entities","namePathListEntities","value","testField","resetWithFieldInitialValue","info","initialValue","props","undefined","records","Set","add","resetWithFields","formInitialValue","join","size","originValue","isListField","skipExist","requiredFieldEntities","r","prevStore","notifyObservers","type","fieldData","data","Object","defineProperty","prevValue","fieldPreserve","mergedPreserve","source","subNamePath","item","defaultValue","triggerDependenciesUpdate","action","updateValue","triggerName","mergedInfo","onStoreChange","childrenFields","getDependencyChildrenFields","relatedFields","onValuesChange","fieldEntity","changedValues","allValues","mergedAllValues","prepareArray","current","triggerOnFieldsChange","touched","rootNamePath","children","dependencies2fields","dependencies","dependency","dependencyNamePath","fillChildren","has","isFieldDirty","filedErrors","onFieldsChange","changedFields","fieldName","arg2","options","provideNameList","finalValueNamePathList","promiseList","TMP_SPLIT","String","Date","now","validateNamePathList","recursive","dirty","rules","promise","validateRules","then","catch","ruleErrors","mergedErrors","mergedWarnings","rule","warningOnly","Promise","reject","summaryPromise","results","resultNamePathList","returnPromise","resolve","errorList","result","errorMessage","message","values","errorFields","outOfDate","e","triggerNamePathList","onFinish","err","console","error","onFinishFailed","useForm","form","formRef","useRef","forceUpdate","useState","forceReRender","formStore"],"sources":["D:/ZSM/beachboys-concert/frontend/node_modules/@rc-component/form/es/hooks/useForm.js"],"sourcesContent":["import { merge } from \"@rc-component/util/es/utils/set\";\nimport { mergeWith } from '@rc-component/util';\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { HOOK_MARK } from \"../FieldContext\";\nimport { allPromiseFinish } from \"../utils/asyncUtil\";\nimport { defaultValidateMessages } from \"../utils/messages\";\nimport NameMap from \"../utils/NameMap\";\nimport { cloneByNamePathList, containsNamePath, getNamePath, getValue, matchNamePath, setValue } from \"../utils/valueUtil\";\nimport WatcherCenter from \"./useNotifyWatch\";\nexport class FormStore {\n  formHooked = false;\n  forceRootUpdate;\n  subscribable = true;\n  store = {};\n  fieldEntities = [];\n  initialValues = {};\n  callbacks = {};\n  validateMessages = null;\n  preserve = null;\n  lastValidatePromise = null;\n  watcherCenter = new WatcherCenter(this);\n  constructor(forceRootUpdate) {\n    this.forceRootUpdate = forceRootUpdate;\n  }\n  getForm = () => ({\n    getFieldValue: this.getFieldValue,\n    getFieldsValue: this.getFieldsValue,\n    getFieldError: this.getFieldError,\n    getFieldWarning: this.getFieldWarning,\n    getFieldsError: this.getFieldsError,\n    isFieldsTouched: this.isFieldsTouched,\n    isFieldTouched: this.isFieldTouched,\n    isFieldValidating: this.isFieldValidating,\n    isFieldsValidating: this.isFieldsValidating,\n    resetFields: this.resetFields,\n    setFields: this.setFields,\n    setFieldValue: this.setFieldValue,\n    setFieldsValue: this.setFieldsValue,\n    validateFields: this.validateFields,\n    submit: this.submit,\n    _init: true,\n    getInternalHooks: this.getInternalHooks\n  });\n\n  // ======================== Internal Hooks ========================\n  getInternalHooks = key => {\n    if (key === HOOK_MARK) {\n      this.formHooked = true;\n      return {\n        dispatch: this.dispatch,\n        initEntityValue: this.initEntityValue,\n        registerField: this.registerField,\n        useSubscribe: this.useSubscribe,\n        setInitialValues: this.setInitialValues,\n        destroyForm: this.destroyForm,\n        setCallbacks: this.setCallbacks,\n        setValidateMessages: this.setValidateMessages,\n        getFields: this.getFields,\n        setPreserve: this.setPreserve,\n        getInitialValue: this.getInitialValue,\n        registerWatch: this.registerWatch\n      };\n    }\n    warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\n    return null;\n  };\n  useSubscribe = subscribable => {\n    this.subscribable = subscribable;\n  };\n\n  /**\n   * Record prev Form unmount fieldEntities which config preserve false.\n   * This need to be refill with initialValues instead of store value.\n   */\n  prevWithoutPreserves = null;\n\n  /**\n   * First time `setInitialValues` should update store with initial value\n   */\n  setInitialValues = (initialValues, init) => {\n    this.initialValues = initialValues || {};\n    if (init) {\n      let nextStore = merge(initialValues, this.store);\n\n      // We will take consider prev form unmount fields.\n      // When the field is not `preserve`, we need fill this with initialValues instead of store.\n      // eslint-disable-next-line array-callback-return\n      this.prevWithoutPreserves?.map(({\n        key: namePath\n      }) => {\n        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\n      });\n      this.prevWithoutPreserves = null;\n      this.updateStore(nextStore);\n    }\n  };\n  destroyForm = clearOnDestroy => {\n    if (clearOnDestroy) {\n      // destroy form reset store\n      this.updateStore({});\n    } else {\n      // Fill preserve fields\n      const prevWithoutPreserves = new NameMap();\n      this.getFieldEntities(true).forEach(entity => {\n        if (!this.isMergedPreserve(entity.isPreserve())) {\n          prevWithoutPreserves.set(entity.getNamePath(), true);\n        }\n      });\n      this.prevWithoutPreserves = prevWithoutPreserves;\n    }\n  };\n  getInitialValue = namePath => {\n    const initValue = getValue(this.initialValues, namePath);\n\n    // Not cloneDeep when without `namePath`\n    return namePath.length ? merge(initValue) : initValue;\n  };\n  setCallbacks = callbacks => {\n    this.callbacks = callbacks;\n  };\n  setValidateMessages = validateMessages => {\n    this.validateMessages = validateMessages;\n  };\n  setPreserve = preserve => {\n    this.preserve = preserve;\n  };\n\n  // ============================= Watch ============================\n  registerWatch = callback => {\n    return this.watcherCenter.register(callback);\n  };\n  notifyWatch = (namePath = []) => {\n    this.watcherCenter.notify(namePath);\n  };\n\n  // ========================== Dev Warning =========================\n  timeoutId = null;\n  warningUnhooked = () => {\n    if (process.env.NODE_ENV !== 'production' && !this.timeoutId && typeof window !== 'undefined') {\n      this.timeoutId = setTimeout(() => {\n        this.timeoutId = null;\n        if (!this.formHooked) {\n          warning(false, 'Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?');\n        }\n      });\n    }\n  };\n\n  // ============================ Store =============================\n  updateStore = nextStore => {\n    this.store = nextStore;\n  };\n\n  // ============================ Fields ============================\n  /**\n   * Get registered field entities.\n   * @param pure Only return field which has a `name`. Default: false\n   */\n  getFieldEntities = (pure = false) => {\n    if (!pure) {\n      return this.fieldEntities;\n    }\n    return this.fieldEntities.filter(field => field.getNamePath().length);\n  };\n\n  /**\n   * Get a map of registered field entities with their name path as the key.\n   * @param pure Only include fields which have a `name`. Default: false\n   * @returns A NameMap containing field entities indexed by their name paths\n   */\n  getFieldsMap = (pure = false) => {\n    const cache = new NameMap();\n    this.getFieldEntities(pure).forEach(field => {\n      const namePath = field.getNamePath();\n      cache.set(namePath, field);\n    });\n    return cache;\n  };\n\n  /**\n   * Get field entities based on a list of name paths.\n   * @param nameList - Array of name paths to search for. If not provided, returns all field entities with names.\n   * @param includesSubNamePath - Whether to include fields that have the given name path as a prefix.\n   */\n  getFieldEntitiesForNamePathList = (nameList, includesSubNamePath = false) => {\n    if (!nameList) {\n      return this.getFieldEntities(true);\n    }\n    const cache = this.getFieldsMap(true);\n    if (!includesSubNamePath) {\n      return nameList.map(name => {\n        const namePath = getNamePath(name);\n        return cache.get(namePath) || {\n          INVALIDATE_NAME_PATH: getNamePath(name)\n        };\n      });\n    }\n    return nameList.flatMap(name => {\n      const namePath = getNamePath(name);\n      const fields = cache.getAsPrefix(namePath);\n      if (fields.length) {\n        return fields;\n      }\n      return [{\n        INVALIDATE_NAME_PATH: namePath\n      }];\n    });\n  };\n  getFieldsValue = (nameList, filterFunc) => {\n    this.warningUnhooked();\n\n    // Fill args\n    let mergedNameList;\n    let mergedFilterFunc;\n    if (nameList === true || Array.isArray(nameList)) {\n      mergedNameList = nameList;\n      mergedFilterFunc = filterFunc;\n    } else if (nameList && typeof nameList === 'object') {\n      mergedFilterFunc = nameList.filter;\n    }\n    if (mergedNameList === true && !mergedFilterFunc) {\n      return this.store;\n    }\n    const fieldEntities = this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null, true);\n    const filteredNameList = [];\n    const listNamePaths = [];\n    fieldEntities.forEach(entity => {\n      const namePath = entity.INVALIDATE_NAME_PATH || entity.getNamePath();\n\n      // Ignore when it's a list item and not specific the namePath,\n      // since parent field is already take in count\n      if (entity.isList?.()) {\n        listNamePaths.push(namePath);\n        return;\n      }\n      if (!mergedFilterFunc) {\n        filteredNameList.push(namePath);\n      } else {\n        const meta = 'getMeta' in entity ? entity.getMeta() : null;\n        if (mergedFilterFunc(meta)) {\n          filteredNameList.push(namePath);\n        }\n      }\n    });\n    let mergedValues = cloneByNamePathList(this.store, filteredNameList.map(getNamePath));\n\n    // We need fill the list as [] if Form.List is empty\n    listNamePaths.forEach(namePath => {\n      if (!getValue(mergedValues, namePath)) {\n        mergedValues = setValue(mergedValues, namePath, []);\n      }\n    });\n    return mergedValues;\n  };\n  getFieldValue = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    return getValue(this.store, namePath);\n  };\n  getFieldsError = nameList => {\n    this.warningUnhooked();\n    const fieldEntities = this.getFieldEntitiesForNamePathList(nameList);\n    return fieldEntities.map((entity, index) => {\n      if (entity && !entity.INVALIDATE_NAME_PATH) {\n        return {\n          name: entity.getNamePath(),\n          errors: entity.getErrors(),\n          warnings: entity.getWarnings()\n        };\n      }\n      return {\n        name: getNamePath(nameList[index]),\n        errors: [],\n        warnings: []\n      };\n    });\n  };\n  getFieldError = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    const fieldError = this.getFieldsError([namePath])[0];\n    return fieldError.errors;\n  };\n  getFieldWarning = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    const fieldError = this.getFieldsError([namePath])[0];\n    return fieldError.warnings;\n  };\n  isFieldsTouched = (...args) => {\n    this.warningUnhooked();\n    const [arg0, arg1] = args;\n    let namePathList;\n    let isAllFieldsTouched = false;\n    if (args.length === 0) {\n      namePathList = null;\n    } else if (args.length === 1) {\n      if (Array.isArray(arg0)) {\n        namePathList = arg0.map(getNamePath);\n        isAllFieldsTouched = false;\n      } else {\n        namePathList = null;\n        isAllFieldsTouched = arg0;\n      }\n    } else {\n      namePathList = arg0.map(getNamePath);\n      isAllFieldsTouched = arg1;\n    }\n    const fieldEntities = this.getFieldEntities(true);\n    const isFieldTouched = field => field.isFieldTouched();\n\n    // ===== Will get fully compare when not config namePathList =====\n    if (!namePathList) {\n      return isAllFieldsTouched ? fieldEntities.every(entity => isFieldTouched(entity) || entity.isList()) : fieldEntities.some(isFieldTouched);\n    }\n\n    // Generate a nest tree for validate\n    const map = new NameMap();\n    namePathList.forEach(shortNamePath => {\n      map.set(shortNamePath, []);\n    });\n    fieldEntities.forEach(field => {\n      const fieldNamePath = field.getNamePath();\n\n      // Find matched entity and put into list\n      namePathList.forEach(shortNamePath => {\n        if (shortNamePath.every((nameUnit, i) => fieldNamePath[i] === nameUnit)) {\n          map.update(shortNamePath, list => [...list, field]);\n        }\n      });\n    });\n\n    // Check if NameMap value is touched\n    const isNamePathListTouched = entities => entities.some(isFieldTouched);\n    const namePathListEntities = map.map(({\n      value\n    }) => value);\n    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\n  };\n  isFieldTouched = name => {\n    this.warningUnhooked();\n    return this.isFieldsTouched([name]);\n  };\n  isFieldsValidating = nameList => {\n    this.warningUnhooked();\n    const fieldEntities = this.getFieldEntities();\n    if (!nameList) {\n      return fieldEntities.some(testField => testField.isFieldValidating());\n    }\n    const namePathList = nameList.map(getNamePath);\n    return fieldEntities.some(testField => {\n      const fieldNamePath = testField.getNamePath();\n      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\n    });\n  };\n  isFieldValidating = name => {\n    this.warningUnhooked();\n    return this.isFieldsValidating([name]);\n  };\n\n  /**\n   * Reset Field with field `initialValue` prop.\n   * Can pass `entities` or `namePathList` or just nothing.\n   */\n  resetWithFieldInitialValue = (info = {}) => {\n    // Create cache\n    const cache = new NameMap();\n    const fieldEntities = this.getFieldEntities(true);\n    fieldEntities.forEach(field => {\n      const {\n        initialValue\n      } = field.props;\n      const namePath = field.getNamePath();\n\n      // Record only if has `initialValue`\n      if (initialValue !== undefined) {\n        const records = cache.get(namePath) || new Set();\n        records.add({\n          entity: field,\n          value: initialValue\n        });\n        cache.set(namePath, records);\n      }\n    });\n\n    // Reset\n    const resetWithFields = entities => {\n      entities.forEach(field => {\n        const {\n          initialValue\n        } = field.props;\n        if (initialValue !== undefined) {\n          const namePath = field.getNamePath();\n          const formInitialValue = this.getInitialValue(namePath);\n          if (formInitialValue !== undefined) {\n            // Warning if conflict with form initialValues and do not modify value\n            warning(false, `Form already set 'initialValues' with path '${namePath.join('.')}'. Field can not overwrite it.`);\n          } else {\n            const records = cache.get(namePath);\n            if (records && records.size > 1) {\n              // Warning if multiple field set `initialValue`and do not modify value\n              warning(false, `Multiple Field with path '${namePath.join('.')}' set 'initialValue'. Can not decide which one to pick.`);\n            } else if (records) {\n              const originValue = this.getFieldValue(namePath);\n              const isListField = field.isListField();\n\n              // Set `initialValue`\n              if (!isListField && (!info.skipExist || originValue === undefined)) {\n                this.updateStore(setValue(this.store, namePath, [...records][0].value));\n              }\n            }\n          }\n        }\n      });\n    };\n    let requiredFieldEntities;\n    if (info.entities) {\n      requiredFieldEntities = info.entities;\n    } else if (info.namePathList) {\n      requiredFieldEntities = [];\n      info.namePathList.forEach(namePath => {\n        const records = cache.get(namePath);\n        if (records) {\n          requiredFieldEntities.push(...[...records].map(r => r.entity));\n        }\n      });\n    } else {\n      requiredFieldEntities = fieldEntities;\n    }\n    resetWithFields(requiredFieldEntities);\n  };\n  resetFields = nameList => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    if (!nameList) {\n      this.updateStore(merge(this.initialValues));\n      this.resetWithFieldInitialValue();\n      this.notifyObservers(prevStore, null, {\n        type: 'reset'\n      });\n      this.notifyWatch();\n      return;\n    }\n\n    // Reset by `nameList`\n    const namePathList = nameList.map(getNamePath);\n    namePathList.forEach(namePath => {\n      const initialValue = this.getInitialValue(namePath);\n      this.updateStore(setValue(this.store, namePath, initialValue));\n    });\n    this.resetWithFieldInitialValue({\n      namePathList\n    });\n    this.notifyObservers(prevStore, namePathList, {\n      type: 'reset'\n    });\n    this.notifyWatch(namePathList);\n  };\n  setFields = fields => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    const namePathList = [];\n    fields.forEach(fieldData => {\n      const {\n        name,\n        ...data\n      } = fieldData;\n      const namePath = getNamePath(name);\n      namePathList.push(namePath);\n\n      // Value\n      if ('value' in data) {\n        this.updateStore(setValue(this.store, namePath, data.value));\n      }\n      this.notifyObservers(prevStore, [namePath], {\n        type: 'setField',\n        data: fieldData\n      });\n    });\n    this.notifyWatch(namePathList);\n  };\n  getFields = () => {\n    const entities = this.getFieldEntities(true);\n    const fields = entities.map(field => {\n      const namePath = field.getNamePath();\n      const meta = field.getMeta();\n      const fieldData = {\n        ...meta,\n        name: namePath,\n        value: this.getFieldValue(namePath)\n      };\n      Object.defineProperty(fieldData, 'originRCField', {\n        value: true\n      });\n      return fieldData;\n    });\n    return fields;\n  };\n\n  // =========================== Observer ===========================\n  /**\n   * This only trigger when a field is on constructor to avoid we get initialValue too late\n   */\n  initEntityValue = entity => {\n    const {\n      initialValue\n    } = entity.props;\n    if (initialValue !== undefined) {\n      const namePath = entity.getNamePath();\n      const prevValue = getValue(this.store, namePath);\n      if (prevValue === undefined) {\n        this.updateStore(setValue(this.store, namePath, initialValue));\n      }\n    }\n  };\n  isMergedPreserve = fieldPreserve => {\n    const mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : this.preserve;\n    return mergedPreserve ?? true;\n  };\n  registerField = entity => {\n    this.fieldEntities.push(entity);\n    const namePath = entity.getNamePath();\n    this.notifyWatch([namePath]);\n\n    // Set initial values\n    if (entity.props.initialValue !== undefined) {\n      const prevStore = this.store;\n      this.resetWithFieldInitialValue({\n        entities: [entity],\n        skipExist: true\n      });\n      this.notifyObservers(prevStore, [entity.getNamePath()], {\n        type: 'valueUpdate',\n        source: 'internal'\n      });\n    }\n\n    // un-register field callback\n    return (isListField, preserve, subNamePath = []) => {\n      this.fieldEntities = this.fieldEntities.filter(item => item !== entity);\n\n      // Clean up store value if not preserve\n      if (!this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {\n        const defaultValue = isListField ? undefined : this.getInitialValue(namePath);\n        if (namePath.length && this.getFieldValue(namePath) !== defaultValue && this.fieldEntities.every(field =>\n        // Only reset when no namePath exist\n        !matchNamePath(field.getNamePath(), namePath))) {\n          const prevStore = this.store;\n          this.updateStore(setValue(prevStore, namePath, defaultValue, true));\n\n          // Notify that field is unmount\n          this.notifyObservers(prevStore, [namePath], {\n            type: 'remove'\n          });\n\n          // Dependencies update\n          this.triggerDependenciesUpdate(prevStore, namePath);\n        }\n      }\n      this.notifyWatch([namePath]);\n    };\n  };\n  dispatch = action => {\n    switch (action.type) {\n      case 'updateValue':\n        {\n          const {\n            namePath,\n            value\n          } = action;\n          this.updateValue(namePath, value);\n          break;\n        }\n      case 'validateField':\n        {\n          const {\n            namePath,\n            triggerName\n          } = action;\n          this.validateFields([namePath], {\n            triggerName\n          });\n          break;\n        }\n      default:\n      // Currently we don't have other action. Do nothing.\n    }\n  };\n  notifyObservers = (prevStore, namePathList, info) => {\n    if (this.subscribable) {\n      const mergedInfo = {\n        ...info,\n        store: this.getFieldsValue(true)\n      };\n      this.getFieldEntities().forEach(({\n        onStoreChange\n      }) => {\n        onStoreChange(prevStore, namePathList, mergedInfo);\n      });\n    } else {\n      this.forceRootUpdate();\n    }\n  };\n\n  /**\n   * Notify dependencies children with parent update\n   * We need delay to trigger validate in case Field is under render props\n   */\n  triggerDependenciesUpdate = (prevStore, namePath) => {\n    const childrenFields = this.getDependencyChildrenFields(namePath);\n    if (childrenFields.length) {\n      this.validateFields(childrenFields);\n    }\n    this.notifyObservers(prevStore, childrenFields, {\n      type: 'dependenciesUpdate',\n      relatedFields: [namePath, ...childrenFields]\n    });\n    return childrenFields;\n  };\n  updateValue = (name, value) => {\n    const namePath = getNamePath(name);\n    const prevStore = this.store;\n    this.updateStore(setValue(this.store, namePath, value));\n    this.notifyObservers(prevStore, [namePath], {\n      type: 'valueUpdate',\n      source: 'internal'\n    });\n    this.notifyWatch([namePath]);\n\n    // Dependencies update\n    const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);\n\n    // trigger callback function\n    const {\n      onValuesChange\n    } = this.callbacks;\n    if (onValuesChange) {\n      const fieldEntity = this.getFieldsMap(true).get(namePath);\n      const changedValues = cloneByNamePathList(this.store, [namePath]);\n      const allValues = this.getFieldsValue();\n      // Merge changedValues into allValues to ensure allValues contains the latest changes\n      const mergedAllValues = mergeWith([allValues, changedValues], {\n        // When value is array, it means trigger by Form.List which should replace directly\n        prepareArray: current => fieldEntity?.isList() ? [] : [...(current || [])]\n      });\n      onValuesChange(changedValues, mergedAllValues);\n    }\n    this.triggerOnFieldsChange([namePath, ...childrenFields]);\n  };\n\n  // Let all child Field get update.\n  setFieldsValue = store => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    if (store) {\n      const nextStore = merge(this.store, store);\n      this.updateStore(nextStore);\n    }\n    this.notifyObservers(prevStore, null, {\n      type: 'valueUpdate',\n      source: 'external'\n    });\n    this.notifyWatch();\n  };\n  setFieldValue = (name, value) => {\n    this.setFields([{\n      name,\n      value,\n      errors: [],\n      warnings: [],\n      touched: true\n    }]);\n  };\n  getDependencyChildrenFields = rootNamePath => {\n    const children = new Set();\n    const childrenFields = [];\n    const dependencies2fields = new NameMap();\n\n    /**\n     * Generate maps\n     * Can use cache to save perf if user report performance issue with this\n     */\n    this.getFieldEntities().forEach(field => {\n      const {\n        dependencies\n      } = field.props;\n      (dependencies || []).forEach(dependency => {\n        const dependencyNamePath = getNamePath(dependency);\n        dependencies2fields.update(dependencyNamePath, (fields = new Set()) => {\n          fields.add(field);\n          return fields;\n        });\n      });\n    });\n    const fillChildren = namePath => {\n      const fields = dependencies2fields.get(namePath) || new Set();\n      fields.forEach(field => {\n        if (!children.has(field)) {\n          children.add(field);\n          const fieldNamePath = field.getNamePath();\n          if (field.isFieldDirty() && fieldNamePath.length) {\n            childrenFields.push(fieldNamePath);\n            fillChildren(fieldNamePath);\n          }\n        }\n      });\n    };\n    fillChildren(rootNamePath);\n    return childrenFields;\n  };\n  triggerOnFieldsChange = (namePathList, filedErrors) => {\n    const {\n      onFieldsChange\n    } = this.callbacks;\n    if (onFieldsChange) {\n      const fields = this.getFields();\n\n      /**\n       * Fill errors since `fields` may be replaced by controlled fields\n       */\n      if (filedErrors) {\n        const cache = new NameMap();\n        filedErrors.forEach(({\n          name,\n          errors\n        }) => {\n          cache.set(name, errors);\n        });\n        fields.forEach(field => {\n          // eslint-disable-next-line no-param-reassign\n          field.errors = cache.get(field.name) || field.errors;\n        });\n      }\n      const changedFields = fields.filter(({\n        name: fieldName\n      }) => containsNamePath(namePathList, fieldName));\n      if (changedFields.length) {\n        onFieldsChange(changedFields, fields);\n      }\n    }\n  };\n\n  // =========================== Validate ===========================\n  validateFields = (arg1, arg2) => {\n    this.warningUnhooked();\n    let nameList;\n    let options;\n    if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {\n      nameList = arg1;\n      options = arg2;\n    } else {\n      options = arg1;\n    }\n    const provideNameList = !!nameList;\n    const namePathList = provideNameList ? nameList.map(getNamePath) : [];\n    // Same namePathList, but does not include Form.List name\n    const finalValueNamePathList = [...namePathList];\n\n    // Collect result in promise list\n    const promiseList = [];\n\n    // We temp save the path which need trigger for `onFieldsChange`\n    const TMP_SPLIT = String(Date.now());\n    const validateNamePathList = new Set();\n    const {\n      recursive,\n      dirty\n    } = options || {};\n    this.getFieldEntities(true).forEach(field => {\n      const fieldNamePath = field.getNamePath();\n\n      // Add field if not provide `nameList`\n      if (!provideNameList) {\n        if (\n        // If is field, pass directly\n        !field.isList() ||\n        // If is list, do not add if already exist sub field in the namePathList\n        !namePathList.some(name => matchNamePath(name, fieldNamePath, true))) {\n          finalValueNamePathList.push(fieldNamePath);\n        }\n        namePathList.push(fieldNamePath);\n      }\n\n      // Skip if without rule\n      if (!field.props.rules || !field.props.rules.length) {\n        return;\n      }\n\n      // Skip if only validate dirty field\n      if (dirty && !field.isFieldDirty()) {\n        return;\n      }\n      validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));\n\n      // Add field validate rule in to promise list\n      if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {\n        const promise = field.validateRules({\n          validateMessages: {\n            ...defaultValidateMessages,\n            ...this.validateMessages\n          },\n          ...options\n        });\n\n        // Wrap promise with field\n        promiseList.push(promise.then(() => ({\n          name: fieldNamePath,\n          errors: [],\n          warnings: []\n        })).catch(ruleErrors => {\n          const mergedErrors = [];\n          const mergedWarnings = [];\n          ruleErrors.forEach?.(({\n            rule: {\n              warningOnly\n            },\n            errors\n          }) => {\n            if (warningOnly) {\n              mergedWarnings.push(...errors);\n            } else {\n              mergedErrors.push(...errors);\n            }\n          });\n          if (mergedErrors.length) {\n            return Promise.reject({\n              name: fieldNamePath,\n              errors: mergedErrors,\n              warnings: mergedWarnings\n            });\n          }\n          return {\n            name: fieldNamePath,\n            errors: mergedErrors,\n            warnings: mergedWarnings\n          };\n        }));\n      }\n    });\n    const summaryPromise = allPromiseFinish(promiseList);\n    this.lastValidatePromise = summaryPromise;\n\n    // Notify fields with rule that validate has finished and need update\n    summaryPromise.catch(results => results).then(results => {\n      const resultNamePathList = results.map(({\n        name\n      }) => name);\n      this.notifyObservers(this.store, resultNamePathList, {\n        type: 'validateFinish'\n      });\n      this.triggerOnFieldsChange(resultNamePathList, results);\n    });\n    const returnPromise = summaryPromise.then(() => {\n      if (this.lastValidatePromise === summaryPromise) {\n        return Promise.resolve(this.getFieldsValue(finalValueNamePathList));\n      }\n      return Promise.reject([]);\n    }).catch(results => {\n      const errorList = results.filter(result => result && result.errors.length);\n      const errorMessage = errorList[0]?.errors?.[0];\n      return Promise.reject({\n        message: errorMessage,\n        values: this.getFieldsValue(namePathList),\n        errorFields: errorList,\n        outOfDate: this.lastValidatePromise !== summaryPromise\n      });\n    });\n\n    // Do not throw in console\n    returnPromise.catch(e => e);\n\n    // `validating` changed. Trigger `onFieldsChange`\n    const triggerNamePathList = namePathList.filter(namePath => validateNamePathList.has(namePath.join(TMP_SPLIT)));\n    this.triggerOnFieldsChange(triggerNamePathList);\n    return returnPromise;\n  };\n\n  // ============================ Submit ============================\n  submit = () => {\n    this.warningUnhooked();\n    this.validateFields().then(values => {\n      const {\n        onFinish\n      } = this.callbacks;\n      if (onFinish) {\n        try {\n          onFinish(values);\n        } catch (err) {\n          // Should print error if user `onFinish` callback failed\n          console.error(err);\n        }\n      }\n    }).catch(e => {\n      const {\n        onFinishFailed\n      } = this.callbacks;\n      if (onFinishFailed) {\n        onFinishFailed(e);\n      }\n    });\n  };\n}\nfunction useForm(form) {\n  const formRef = React.useRef(null);\n  const [, forceUpdate] = React.useState({});\n\n  // Create singleton FormStore\n  if (!formRef.current) {\n    if (form) {\n      formRef.current = form;\n    } else {\n      // Create a new FormStore if not provided\n      const forceReRender = () => {\n        forceUpdate({});\n      };\n      const formStore = new FormStore(forceReRender);\n      formRef.current = formStore.getForm();\n    }\n  }\n  return [formRef.current];\n}\nexport default useForm;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}