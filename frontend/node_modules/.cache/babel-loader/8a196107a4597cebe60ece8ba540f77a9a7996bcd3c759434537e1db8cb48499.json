{"ast":null,"code":"import { useControlledState, useEvent } from '@rc-component/util';\nimport { useRef, useState, useEffect } from 'react';\nconst internalMacroTask = fn => {\n  const channel = new MessageChannel();\n  channel.port1.onmessage = fn;\n  channel.port2.postMessage(null);\n};\nexport const macroTask = (fn, times = 1) => {\n  if (times <= 0) {\n    fn();\n    return;\n  }\n  internalMacroTask(() => {\n    macroTask(fn, times - 1);\n  });\n};\n\n/**\n * Trigger by latest open call, if nextOpen is undefined, means toggle.\n * `weak` means this call can be ignored if previous call exists.\n */\n\n/**\n * When `open` is controlled, follow the controlled value;\n * Otherwise use uncontrolled logic.\n * Setting `open` takes effect immediately,\n * but setting it to `false` is delayed via MessageChannel.\n *\n * SSR handling: During SSR, `open` is always false to avoid Portal issues.\n * On client-side hydration, it syncs with the actual open state.\n */\nexport default function useOpen(defaultOpen, propOpen, onOpen, postOpen) {\n  // SSR not support Portal which means we need delay `open` for the first time render\n  const [rendered, setRendered] = useState(false);\n  useEffect(() => {\n    setRendered(true);\n  }, []);\n  const [stateOpen, internalSetOpen] = useControlledState(defaultOpen, propOpen);\n\n  // Lock for options update\n  const [lock, setLock] = useState(false);\n\n  // During SSR, always return false for open state\n  const ssrSafeOpen = rendered ? stateOpen : false;\n  const mergedOpen = postOpen(ssrSafeOpen);\n  const taskIdRef = useRef(0);\n  const triggerEvent = useEvent(nextOpen => {\n    if (onOpen && mergedOpen !== nextOpen) {\n      onOpen(nextOpen);\n    }\n    internalSetOpen(nextOpen);\n  });\n  const toggleOpen = useEvent((nextOpen, config = {}) => {\n    const {\n      cancelFun\n    } = config;\n    taskIdRef.current += 1;\n    const id = taskIdRef.current;\n    const nextOpenVal = typeof nextOpen === 'boolean' ? nextOpen : !mergedOpen;\n    setLock(!nextOpenVal);\n    function triggerUpdate() {\n      if (\n      // Always check if id is match\n      id === taskIdRef.current &&\n      // Check if need to cancel\n      !cancelFun?.()) {\n        triggerEvent(nextOpenVal);\n        setLock(false);\n      }\n    }\n\n    // Weak update can be ignored\n    if (nextOpenVal) {\n      triggerUpdate();\n    } else {\n      macroTask(() => {\n        triggerUpdate();\n      });\n    }\n  });\n  return [ssrSafeOpen, mergedOpen, toggleOpen, lock];\n}","map":{"version":3,"names":["useControlledState","useEvent","useRef","useState","useEffect","internalMacroTask","fn","channel","MessageChannel","port1","onmessage","port2","postMessage","macroTask","times","useOpen","defaultOpen","propOpen","onOpen","postOpen","rendered","setRendered","stateOpen","internalSetOpen","lock","setLock","ssrSafeOpen","mergedOpen","taskIdRef","triggerEvent","nextOpen","toggleOpen","config","cancelFun","current","id","nextOpenVal","triggerUpdate"],"sources":["D:/ZSM/beachboys-concert/frontend/node_modules/@rc-component/select/es/hooks/useOpen.js"],"sourcesContent":["import { useControlledState, useEvent } from '@rc-component/util';\nimport { useRef, useState, useEffect } from 'react';\nconst internalMacroTask = fn => {\n  const channel = new MessageChannel();\n  channel.port1.onmessage = fn;\n  channel.port2.postMessage(null);\n};\nexport const macroTask = (fn, times = 1) => {\n  if (times <= 0) {\n    fn();\n    return;\n  }\n  internalMacroTask(() => {\n    macroTask(fn, times - 1);\n  });\n};\n\n/**\n * Trigger by latest open call, if nextOpen is undefined, means toggle.\n * `weak` means this call can be ignored if previous call exists.\n */\n\n/**\n * When `open` is controlled, follow the controlled value;\n * Otherwise use uncontrolled logic.\n * Setting `open` takes effect immediately,\n * but setting it to `false` is delayed via MessageChannel.\n *\n * SSR handling: During SSR, `open` is always false to avoid Portal issues.\n * On client-side hydration, it syncs with the actual open state.\n */\nexport default function useOpen(defaultOpen, propOpen, onOpen, postOpen) {\n  // SSR not support Portal which means we need delay `open` for the first time render\n  const [rendered, setRendered] = useState(false);\n  useEffect(() => {\n    setRendered(true);\n  }, []);\n  const [stateOpen, internalSetOpen] = useControlledState(defaultOpen, propOpen);\n\n  // Lock for options update\n  const [lock, setLock] = useState(false);\n\n  // During SSR, always return false for open state\n  const ssrSafeOpen = rendered ? stateOpen : false;\n  const mergedOpen = postOpen(ssrSafeOpen);\n  const taskIdRef = useRef(0);\n  const triggerEvent = useEvent(nextOpen => {\n    if (onOpen && mergedOpen !== nextOpen) {\n      onOpen(nextOpen);\n    }\n    internalSetOpen(nextOpen);\n  });\n  const toggleOpen = useEvent((nextOpen, config = {}) => {\n    const {\n      cancelFun\n    } = config;\n    taskIdRef.current += 1;\n    const id = taskIdRef.current;\n    const nextOpenVal = typeof nextOpen === 'boolean' ? nextOpen : !mergedOpen;\n    setLock(!nextOpenVal);\n    function triggerUpdate() {\n      if (\n      // Always check if id is match\n      id === taskIdRef.current &&\n      // Check if need to cancel\n      !cancelFun?.()) {\n        triggerEvent(nextOpenVal);\n        setLock(false);\n      }\n    }\n\n    // Weak update can be ignored\n    if (nextOpenVal) {\n      triggerUpdate();\n    } else {\n      macroTask(() => {\n        triggerUpdate();\n      });\n    }\n  });\n  return [ssrSafeOpen, mergedOpen, toggleOpen, lock];\n}"],"mappings":"AAAA,SAASA,kBAAkB,EAAEC,QAAQ,QAAQ,oBAAoB;AACjE,SAASC,MAAM,EAAEC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AACnD,MAAMC,iBAAiB,GAAGC,EAAE,IAAI;EAC9B,MAAMC,OAAO,GAAG,IAAIC,cAAc,CAAC,CAAC;EACpCD,OAAO,CAACE,KAAK,CAACC,SAAS,GAAGJ,EAAE;EAC5BC,OAAO,CAACI,KAAK,CAACC,WAAW,CAAC,IAAI,CAAC;AACjC,CAAC;AACD,OAAO,MAAMC,SAAS,GAAGA,CAACP,EAAE,EAAEQ,KAAK,GAAG,CAAC,KAAK;EAC1C,IAAIA,KAAK,IAAI,CAAC,EAAE;IACdR,EAAE,CAAC,CAAC;IACJ;EACF;EACAD,iBAAiB,CAAC,MAAM;IACtBQ,SAAS,CAACP,EAAE,EAAEQ,KAAK,GAAG,CAAC,CAAC;EAC1B,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,OAAOA,CAACC,WAAW,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,QAAQ,EAAE;EACvE;EACA,MAAM,CAACC,QAAQ,EAAEC,WAAW,CAAC,GAAGlB,QAAQ,CAAC,KAAK,CAAC;EAC/CC,SAAS,CAAC,MAAM;IACdiB,WAAW,CAAC,IAAI,CAAC;EACnB,CAAC,EAAE,EAAE,CAAC;EACN,MAAM,CAACC,SAAS,EAAEC,eAAe,CAAC,GAAGvB,kBAAkB,CAACgB,WAAW,EAAEC,QAAQ,CAAC;;EAE9E;EACA,MAAM,CAACO,IAAI,EAAEC,OAAO,CAAC,GAAGtB,QAAQ,CAAC,KAAK,CAAC;;EAEvC;EACA,MAAMuB,WAAW,GAAGN,QAAQ,GAAGE,SAAS,GAAG,KAAK;EAChD,MAAMK,UAAU,GAAGR,QAAQ,CAACO,WAAW,CAAC;EACxC,MAAME,SAAS,GAAG1B,MAAM,CAAC,CAAC,CAAC;EAC3B,MAAM2B,YAAY,GAAG5B,QAAQ,CAAC6B,QAAQ,IAAI;IACxC,IAAIZ,MAAM,IAAIS,UAAU,KAAKG,QAAQ,EAAE;MACrCZ,MAAM,CAACY,QAAQ,CAAC;IAClB;IACAP,eAAe,CAACO,QAAQ,CAAC;EAC3B,CAAC,CAAC;EACF,MAAMC,UAAU,GAAG9B,QAAQ,CAAC,CAAC6B,QAAQ,EAAEE,MAAM,GAAG,CAAC,CAAC,KAAK;IACrD,MAAM;MACJC;IACF,CAAC,GAAGD,MAAM;IACVJ,SAAS,CAACM,OAAO,IAAI,CAAC;IACtB,MAAMC,EAAE,GAAGP,SAAS,CAACM,OAAO;IAC5B,MAAME,WAAW,GAAG,OAAON,QAAQ,KAAK,SAAS,GAAGA,QAAQ,GAAG,CAACH,UAAU;IAC1EF,OAAO,CAAC,CAACW,WAAW,CAAC;IACrB,SAASC,aAAaA,CAAA,EAAG;MACvB;MACA;MACAF,EAAE,KAAKP,SAAS,CAACM,OAAO;MACxB;MACA,CAACD,SAAS,GAAG,CAAC,EAAE;QACdJ,YAAY,CAACO,WAAW,CAAC;QACzBX,OAAO,CAAC,KAAK,CAAC;MAChB;IACF;;IAEA;IACA,IAAIW,WAAW,EAAE;MACfC,aAAa,CAAC,CAAC;IACjB,CAAC,MAAM;MACLxB,SAAS,CAAC,MAAM;QACdwB,aAAa,CAAC,CAAC;MACjB,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;EACF,OAAO,CAACX,WAAW,EAAEC,UAAU,EAAEI,UAAU,EAAEP,IAAI,CAAC;AACpD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}