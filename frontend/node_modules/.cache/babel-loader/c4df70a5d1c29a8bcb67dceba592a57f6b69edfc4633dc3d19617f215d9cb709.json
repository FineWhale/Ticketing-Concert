{"ast":null,"code":"import Portal from '@rc-component/portal';\nimport { clsx } from 'clsx';\nimport { useResizeObserver } from '@rc-component/resize-observer';\nimport { getDOM, isDOM } from \"@rc-component/util/es/Dom/findDOMNode\";\nimport { getShadowRoot } from \"@rc-component/util/es/Dom/shadow\";\nimport { getNodeRef, useComposeRef } from \"@rc-component/util/es/ref\";\nimport useEvent from \"@rc-component/util/es/hooks/useEvent\";\nimport useId from \"@rc-component/util/es/hooks/useId\";\nimport useLayoutEffect from \"@rc-component/util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nimport Popup from \"./Popup\";\nimport TriggerContext, { UniqueContext } from \"./context\";\nimport useAction from \"./hooks/useAction\";\nimport useAlign from \"./hooks/useAlign\";\nimport useDelay from \"./hooks/useDelay\";\nimport useWatch from \"./hooks/useWatch\";\nimport useWinClick from \"./hooks/useWinClick\";\nimport { getAlignPopupClassName } from \"./util\";\nimport UniqueProvider from \"./UniqueProvider\";\nimport { useControlledState } from '@rc-component/util';\nimport { flushSync } from 'react-dom';\nexport { UniqueProvider };\n\n// Removed Props List\n// Seems this can be auto\n// getDocument?: (element?: HTMLElement) => Document;\n\n// New version will not wrap popup with `rc-trigger-popup-content` when multiple children\n\nexport function generateTrigger(PortalComponent = Portal) {\n  const Trigger = /*#__PURE__*/React.forwardRef((props, ref) => {\n    const {\n      prefixCls = 'rc-trigger-popup',\n      children,\n      // Action\n      action = 'hover',\n      showAction,\n      hideAction,\n      // Open\n      popupVisible,\n      defaultPopupVisible,\n      onOpenChange,\n      afterOpenChange,\n      onPopupVisibleChange,\n      afterPopupVisibleChange,\n      // Delay\n      mouseEnterDelay,\n      mouseLeaveDelay = 0.1,\n      focusDelay,\n      blurDelay,\n      // Mask\n      mask,\n      maskClosable = true,\n      // Portal\n      getPopupContainer,\n      forceRender,\n      autoDestroy,\n      // Popup\n      popup,\n      popupClassName,\n      uniqueContainerClassName,\n      uniqueContainerStyle,\n      popupStyle,\n      popupPlacement,\n      builtinPlacements = {},\n      popupAlign,\n      zIndex,\n      stretch,\n      getPopupClassNameFromAlign,\n      fresh,\n      unique,\n      alignPoint,\n      onPopupClick,\n      onPopupAlign,\n      // Arrow\n      arrow,\n      // Motion\n      popupMotion,\n      maskMotion,\n      // Private\n      mobile,\n      ...restProps\n    } = props;\n    const mergedAutoDestroy = autoDestroy || false;\n    const openUncontrolled = popupVisible === undefined;\n\n    // =========================== Mobile ===========================\n    const isMobile = !!mobile;\n\n    // ========================== Context ===========================\n    const subPopupElements = React.useRef({});\n    const parentContext = React.useContext(TriggerContext);\n    const context = React.useMemo(() => {\n      return {\n        registerSubPopup: (id, subPopupEle) => {\n          subPopupElements.current[id] = subPopupEle;\n          parentContext?.registerSubPopup(id, subPopupEle);\n        }\n      };\n    }, [parentContext]);\n\n    // ======================== UniqueContext =========================\n    const uniqueContext = React.useContext(UniqueContext);\n\n    // =========================== Popup ============================\n    const id = useId();\n    const [popupEle, setPopupEle] = React.useState(null);\n\n    // Used for forwardRef popup. Not use internal\n    const externalPopupRef = React.useRef(null);\n    const setPopupRef = useEvent(node => {\n      externalPopupRef.current = node;\n      if (isDOM(node) && popupEle !== node) {\n        setPopupEle(node);\n      }\n      parentContext?.registerSubPopup(id, node);\n    });\n\n    // =========================== Target ===========================\n    // Use state to control here since `useRef` update not trigger render\n    const [targetEle, setTargetEle] = React.useState(null);\n\n    // Used for forwardRef target. Not use internal\n    const externalForwardRef = React.useRef(null);\n    const setTargetRef = useEvent(node => {\n      const domNode = getDOM(node);\n      if (isDOM(domNode) && targetEle !== domNode) {\n        setTargetEle(domNode);\n        externalForwardRef.current = domNode;\n      }\n    });\n    const cloneProps = {};\n    const inPopupOrChild = useEvent(ele => {\n      const childDOM = targetEle;\n      return childDOM?.contains(ele) || getShadowRoot(childDOM)?.host === ele || ele === childDOM || popupEle?.contains(ele) || getShadowRoot(popupEle)?.host === ele || ele === popupEle || Object.values(subPopupElements.current).some(subPopupEle => subPopupEle?.contains(ele) || ele === subPopupEle);\n    });\n\n    // =========================== Arrow ============================\n    const innerArrow = arrow ? {\n      // true and Object likely\n      ...(arrow !== true ? arrow : {})\n    } : null;\n\n    // ============================ Open ============================\n    const [internalOpen, setInternalOpen] = useControlledState(defaultPopupVisible || false, popupVisible);\n    const mergedOpen = internalOpen || false;\n\n    // ========================== Children ==========================\n    const child = React.useMemo(() => {\n      const nextChild = typeof children === 'function' ? children({\n        open: mergedOpen\n      }) : children;\n      return React.Children.only(nextChild);\n    }, [children, mergedOpen]);\n    const originChildProps = child?.props || {};\n\n    // Support ref\n    const isOpen = useEvent(() => mergedOpen);\n\n    // Extract common options for UniqueProvider\n    const getUniqueOptions = useEvent((delay = 0) => ({\n      popup,\n      target: targetEle,\n      delay,\n      prefixCls,\n      popupClassName,\n      uniqueContainerClassName,\n      uniqueContainerStyle,\n      popupStyle,\n      popupPlacement,\n      builtinPlacements,\n      popupAlign,\n      zIndex,\n      mask,\n      maskClosable,\n      popupMotion,\n      maskMotion,\n      arrow: innerArrow,\n      getPopupContainer,\n      getPopupClassNameFromAlign,\n      id,\n      onEsc\n    }));\n\n    // Handle controlled state changes for UniqueProvider\n    // Only sync to UniqueProvider when it's controlled mode\n    // If there is a parentContext, don't call uniqueContext methods\n    useLayoutEffect(() => {\n      if (uniqueContext && unique && targetEle && !openUncontrolled && !parentContext) {\n        if (mergedOpen) {\n          uniqueContext.show(getUniqueOptions(mouseEnterDelay), isOpen);\n        } else {\n          uniqueContext.hide(mouseLeaveDelay);\n        }\n      }\n    }, [mergedOpen, targetEle]);\n    const openRef = React.useRef(mergedOpen);\n    openRef.current = mergedOpen;\n    const internalTriggerOpen = useEvent(nextOpen => {\n      flushSync(() => {\n        if (mergedOpen !== nextOpen) {\n          setInternalOpen(nextOpen);\n          onOpenChange?.(nextOpen);\n          onPopupVisibleChange?.(nextOpen);\n        }\n      });\n    });\n\n    // Trigger for delay\n    const delayInvoke = useDelay();\n    const triggerOpen = (nextOpen, delay = 0) => {\n      // If it's controlled mode, always use internal trigger logic\n      // UniqueProvider will be synced through useLayoutEffect\n      if (popupVisible !== undefined) {\n        delayInvoke(() => {\n          internalTriggerOpen(nextOpen);\n        }, delay);\n        return;\n      }\n\n      // If UniqueContext exists and not controlled, pass delay to Provider instead of handling it internally\n      // If there is a parentContext, don't call uniqueContext methods\n      if (uniqueContext && unique && openUncontrolled && !parentContext) {\n        if (nextOpen) {\n          uniqueContext.show(getUniqueOptions(delay), isOpen);\n        } else {\n          uniqueContext.hide(delay);\n        }\n        return;\n      }\n      delayInvoke(() => {\n        internalTriggerOpen(nextOpen);\n      }, delay);\n    };\n    function onEsc({\n      top\n    }) {\n      if (top) {\n        triggerOpen(false);\n      }\n    }\n\n    // ========================== Motion ============================\n    const [inMotion, setInMotion] = React.useState(false);\n    useLayoutEffect(firstMount => {\n      if (!firstMount || mergedOpen) {\n        setInMotion(true);\n      }\n    }, [mergedOpen]);\n    const [motionPrepareResolve, setMotionPrepareResolve] = React.useState(null);\n\n    // =========================== Align ============================\n    const [mousePos, setMousePos] = React.useState(null);\n    const setMousePosByEvent = event => {\n      setMousePos([event.clientX, event.clientY]);\n    };\n    const [ready, offsetX, offsetY, offsetR, offsetB, arrowX, arrowY, scaleX, scaleY, alignInfo, onAlign] = useAlign(mergedOpen, popupEle, alignPoint && mousePos !== null ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign, isMobile);\n    const [showActions, hideActions] = useAction(action, showAction, hideAction);\n    const clickToShow = showActions.has('click');\n    const clickToHide = hideActions.has('click') || hideActions.has('contextMenu');\n    const triggerAlign = useEvent(() => {\n      if (!inMotion) {\n        onAlign();\n      }\n    });\n    const onScroll = () => {\n      if (openRef.current && alignPoint && clickToHide) {\n        triggerOpen(false);\n      }\n    };\n    useWatch(mergedOpen, targetEle, popupEle, triggerAlign, onScroll);\n    useLayoutEffect(() => {\n      triggerAlign();\n    }, [mousePos, popupPlacement]);\n\n    // When no builtinPlacements and popupAlign changed\n    useLayoutEffect(() => {\n      if (mergedOpen && !builtinPlacements?.[popupPlacement]) {\n        triggerAlign();\n      }\n    }, [JSON.stringify(popupAlign)]);\n    const alignedClassName = React.useMemo(() => {\n      const baseClassName = getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint);\n      return clsx(baseClassName, getPopupClassNameFromAlign?.(alignInfo));\n    }, [alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint]);\n\n    // ============================ Refs ============================\n    React.useImperativeHandle(ref, () => ({\n      nativeElement: externalForwardRef.current,\n      popupElement: externalPopupRef.current,\n      forceAlign: triggerAlign\n    }));\n\n    // ========================== Stretch ===========================\n    const [targetWidth, setTargetWidth] = React.useState(0);\n    const [targetHeight, setTargetHeight] = React.useState(0);\n    const syncTargetSize = () => {\n      if (stretch && targetEle) {\n        const rect = targetEle.getBoundingClientRect();\n        setTargetWidth(rect.width);\n        setTargetHeight(rect.height);\n      }\n    };\n    const onTargetResize = () => {\n      syncTargetSize();\n      triggerAlign();\n    };\n\n    // ========================== Motion ============================\n    const onVisibleChanged = visible => {\n      setInMotion(false);\n      onAlign();\n      afterOpenChange?.(visible);\n      afterPopupVisibleChange?.(visible);\n    };\n\n    // We will trigger align when motion is in prepare\n    const onPrepare = () => new Promise(resolve => {\n      syncTargetSize();\n      setMotionPrepareResolve(() => resolve);\n    });\n    useLayoutEffect(() => {\n      if (motionPrepareResolve) {\n        onAlign();\n        motionPrepareResolve();\n        setMotionPrepareResolve(null);\n      }\n    }, [motionPrepareResolve]);\n\n    // =========================== Action ===========================\n    /**\n     * Util wrapper for trigger action\n     * @param eventName  Listen event name\n     * @param nextOpen  Next open state after trigger\n     * @param delay Delay to trigger open change\n     * @param callback Callback if current event need additional action\n     * @param ignoreCheck  Ignore current event if check return true\n     */\n    function wrapperAction(eventName, nextOpen, delay, callback, ignoreCheck) {\n      cloneProps[eventName] = (event, ...args) => {\n        if (!ignoreCheck || !ignoreCheck()) {\n          callback?.(event);\n          triggerOpen(nextOpen, delay);\n        }\n\n        // Pass to origin\n        originChildProps[eventName]?.(event, ...args);\n      };\n    }\n\n    // ======================= Action: Touch ========================\n    const touchToShow = showActions.has('touch');\n    const touchToHide = hideActions.has('touch');\n\n    /** Used for prevent `hover` event conflict with mobile env */\n    const touchedRef = React.useRef(false);\n    if (touchToShow || touchToHide) {\n      cloneProps.onTouchStart = (...args) => {\n        touchedRef.current = true;\n        if (openRef.current && touchToHide) {\n          triggerOpen(false);\n        } else if (!openRef.current && touchToShow) {\n          triggerOpen(true);\n        }\n\n        // Pass to origin\n        originChildProps.onTouchStart?.(...args);\n      };\n    }\n\n    // ======================= Action: Click ========================\n    if (clickToShow || clickToHide) {\n      cloneProps.onClick = (event, ...args) => {\n        if (openRef.current && clickToHide) {\n          triggerOpen(false);\n        } else if (!openRef.current && clickToShow) {\n          setMousePosByEvent(event);\n          triggerOpen(true);\n        }\n\n        // Pass to origin\n        originChildProps.onClick?.(event, ...args);\n        touchedRef.current = false;\n      };\n    }\n\n    // Click to hide is special action since click popup element should not hide\n    const onPopupPointerDown = useWinClick(mergedOpen, clickToHide || touchToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen);\n\n    // ======================= Action: Hover ========================\n    const hoverToShow = showActions.has('hover');\n    const hoverToHide = hideActions.has('hover');\n    let onPopupMouseEnter;\n    let onPopupMouseLeave;\n    const ignoreMouseTrigger = () => {\n      return touchedRef.current;\n    };\n    if (hoverToShow) {\n      const onMouseEnterCallback = event => {\n        setMousePosByEvent(event);\n      };\n\n      // Compatible with old browser which not support pointer event\n      wrapperAction('onMouseEnter', true, mouseEnterDelay, onMouseEnterCallback, ignoreMouseTrigger);\n      wrapperAction('onPointerEnter', true, mouseEnterDelay, onMouseEnterCallback, ignoreMouseTrigger);\n      onPopupMouseEnter = event => {\n        // Only trigger re-open when popup is visible\n        if ((mergedOpen || inMotion) && popupEle?.contains(event.target)) {\n          triggerOpen(true, mouseEnterDelay);\n        }\n      };\n\n      // Align Point\n      if (alignPoint) {\n        cloneProps.onMouseMove = event => {\n          originChildProps.onMouseMove?.(event);\n        };\n      }\n    }\n    if (hoverToHide) {\n      wrapperAction('onMouseLeave', false, mouseLeaveDelay, undefined, ignoreMouseTrigger);\n      wrapperAction('onPointerLeave', false, mouseLeaveDelay, undefined, ignoreMouseTrigger);\n      onPopupMouseLeave = () => {\n        triggerOpen(false, mouseLeaveDelay);\n      };\n    }\n\n    // ======================= Action: Focus ========================\n    if (showActions.has('focus')) {\n      wrapperAction('onFocus', true, focusDelay);\n    }\n    if (hideActions.has('focus')) {\n      wrapperAction('onBlur', false, blurDelay);\n    }\n\n    // ==================== Action: ContextMenu =====================\n    if (showActions.has('contextMenu')) {\n      cloneProps.onContextMenu = (event, ...args) => {\n        if (openRef.current && hideActions.has('contextMenu')) {\n          triggerOpen(false);\n        } else {\n          setMousePosByEvent(event);\n          triggerOpen(true);\n        }\n        event.preventDefault();\n\n        // Pass to origin\n        originChildProps.onContextMenu?.(event, ...args);\n      };\n    }\n\n    // ============================ Perf ============================\n    const rendedRef = React.useRef(false);\n    rendedRef.current ||= forceRender || mergedOpen || inMotion;\n\n    // =========================== Render ===========================\n    const mergedChildrenProps = {\n      ...originChildProps,\n      ...cloneProps\n    };\n\n    // Pass props into cloneProps for nest usage\n    const passedProps = {};\n    const passedEventList = ['onContextMenu', 'onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter', 'onMouseLeave', 'onFocus', 'onBlur'];\n    passedEventList.forEach(eventName => {\n      if (restProps[eventName]) {\n        passedProps[eventName] = (...args) => {\n          mergedChildrenProps[eventName]?.(...args);\n          restProps[eventName](...args);\n        };\n      }\n    });\n    const arrowPos = {\n      x: arrowX,\n      y: arrowY\n    };\n\n    // =================== Resize Observer ===================\n    // Use hook to observe target element resize\n    // Pass targetEle directly instead of a function so the hook will re-observe when target changes\n    useResizeObserver(mergedOpen, targetEle, onTargetResize);\n\n    // Compose refs\n    const mergedRef = useComposeRef(setTargetRef, getNodeRef(child));\n\n    // Child Node\n    const triggerNode = /*#__PURE__*/React.cloneElement(child, {\n      ...mergedChildrenProps,\n      ...passedProps,\n      ref: mergedRef\n    });\n\n    // Render\n    return /*#__PURE__*/React.createElement(React.Fragment, null, triggerNode, rendedRef.current && (!uniqueContext || !unique) && /*#__PURE__*/React.createElement(TriggerContext.Provider, {\n      value: context\n    }, /*#__PURE__*/React.createElement(Popup, {\n      portal: PortalComponent,\n      ref: setPopupRef,\n      prefixCls: prefixCls,\n      popup: popup,\n      className: clsx(popupClassName, !isMobile && alignedClassName),\n      style: popupStyle,\n      target: targetEle,\n      onMouseEnter: onPopupMouseEnter,\n      onMouseLeave: onPopupMouseLeave\n      // https://github.com/ant-design/ant-design/issues/43924\n      ,\n\n      onPointerEnter: onPopupMouseEnter,\n      zIndex: zIndex\n      // Open\n      ,\n\n      open: mergedOpen,\n      keepDom: inMotion,\n      fresh: fresh\n      // Click\n      ,\n\n      onClick: onPopupClick,\n      onPointerDownCapture: onPopupPointerDown\n      // Mask\n      ,\n\n      mask: mask\n      // Motion\n      ,\n\n      motion: popupMotion,\n      maskMotion: maskMotion,\n      onVisibleChanged: onVisibleChanged,\n      onPrepare: onPrepare\n      // Portal\n      ,\n\n      forceRender: forceRender,\n      autoDestroy: mergedAutoDestroy,\n      getPopupContainer: getPopupContainer,\n      onEsc: onEsc\n      // Arrow\n      ,\n\n      align: alignInfo,\n      arrow: innerArrow,\n      arrowPos: arrowPos\n      // Align\n      ,\n\n      ready: ready,\n      offsetX: offsetX,\n      offsetY: offsetY,\n      offsetR: offsetR,\n      offsetB: offsetB,\n      onAlign: triggerAlign\n      // Stretch\n      ,\n\n      stretch: stretch,\n      targetWidth: targetWidth / scaleX,\n      targetHeight: targetHeight / scaleY\n      // Mobile\n      ,\n\n      mobile: mobile\n    })));\n  });\n  if (process.env.NODE_ENV !== 'production') {\n    Trigger.displayName = 'Trigger';\n  }\n  return Trigger;\n}\nexport default generateTrigger(Portal);","map":{"version":3,"names":["Portal","clsx","useResizeObserver","getDOM","isDOM","getShadowRoot","getNodeRef","useComposeRef","useEvent","useId","useLayoutEffect","React","Popup","TriggerContext","UniqueContext","useAction","useAlign","useDelay","useWatch","useWinClick","getAlignPopupClassName","UniqueProvider","useControlledState","flushSync","generateTrigger","PortalComponent","Trigger","forwardRef","props","ref","prefixCls","children","action","showAction","hideAction","popupVisible","defaultPopupVisible","onOpenChange","afterOpenChange","onPopupVisibleChange","afterPopupVisibleChange","mouseEnterDelay","mouseLeaveDelay","focusDelay","blurDelay","mask","maskClosable","getPopupContainer","forceRender","autoDestroy","popup","popupClassName","uniqueContainerClassName","uniqueContainerStyle","popupStyle","popupPlacement","builtinPlacements","popupAlign","zIndex","stretch","getPopupClassNameFromAlign","fresh","unique","alignPoint","onPopupClick","onPopupAlign","arrow","popupMotion","maskMotion","mobile","restProps","mergedAutoDestroy","openUncontrolled","undefined","isMobile","subPopupElements","useRef","parentContext","useContext","context","useMemo","registerSubPopup","id","subPopupEle","current","uniqueContext","popupEle","setPopupEle","useState","externalPopupRef","setPopupRef","node","targetEle","setTargetEle","externalForwardRef","setTargetRef","domNode","cloneProps","inPopupOrChild","ele","childDOM","contains","host","Object","values","some","innerArrow","internalOpen","setInternalOpen","mergedOpen","child","nextChild","open","Children","only","originChildProps","isOpen","getUniqueOptions","delay","target","onEsc","show","hide","openRef","internalTriggerOpen","nextOpen","delayInvoke","triggerOpen","top","inMotion","setInMotion","firstMount","motionPrepareResolve","setMotionPrepareResolve","mousePos","setMousePos","setMousePosByEvent","event","clientX","clientY","ready","offsetX","offsetY","offsetR","offsetB","arrowX","arrowY","scaleX","scaleY","alignInfo","onAlign","showActions","hideActions","clickToShow","has","clickToHide","triggerAlign","onScroll","JSON","stringify","alignedClassName","baseClassName","useImperativeHandle","nativeElement","popupElement","forceAlign","targetWidth","setTargetWidth","targetHeight","setTargetHeight","syncTargetSize","rect","getBoundingClientRect","width","height","onTargetResize","onVisibleChanged","visible","onPrepare","Promise","resolve","wrapperAction","eventName","callback","ignoreCheck","args","touchToShow","touchToHide","touchedRef","onTouchStart","onClick","onPopupPointerDown","hoverToShow","hoverToHide","onPopupMouseEnter","onPopupMouseLeave","ignoreMouseTrigger","onMouseEnterCallback","onMouseMove","onContextMenu","preventDefault","rendedRef","mergedChildrenProps","passedProps","passedEventList","forEach","arrowPos","x","y","mergedRef","triggerNode","cloneElement","createElement","Fragment","Provider","value","portal","className","style","onMouseEnter","onMouseLeave","onPointerEnter","keepDom","onPointerDownCapture","motion","align","process","env","NODE_ENV","displayName"],"sources":["D:/ZSM/beachboys-concert/frontend/node_modules/@rc-component/trigger/es/index.js"],"sourcesContent":["import Portal from '@rc-component/portal';\nimport { clsx } from 'clsx';\nimport { useResizeObserver } from '@rc-component/resize-observer';\nimport { getDOM, isDOM } from \"@rc-component/util/es/Dom/findDOMNode\";\nimport { getShadowRoot } from \"@rc-component/util/es/Dom/shadow\";\nimport { getNodeRef, useComposeRef } from \"@rc-component/util/es/ref\";\nimport useEvent from \"@rc-component/util/es/hooks/useEvent\";\nimport useId from \"@rc-component/util/es/hooks/useId\";\nimport useLayoutEffect from \"@rc-component/util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nimport Popup from \"./Popup\";\nimport TriggerContext, { UniqueContext } from \"./context\";\nimport useAction from \"./hooks/useAction\";\nimport useAlign from \"./hooks/useAlign\";\nimport useDelay from \"./hooks/useDelay\";\nimport useWatch from \"./hooks/useWatch\";\nimport useWinClick from \"./hooks/useWinClick\";\nimport { getAlignPopupClassName } from \"./util\";\nimport UniqueProvider from \"./UniqueProvider\";\nimport { useControlledState } from '@rc-component/util';\nimport { flushSync } from 'react-dom';\nexport { UniqueProvider };\n\n// Removed Props List\n// Seems this can be auto\n// getDocument?: (element?: HTMLElement) => Document;\n\n// New version will not wrap popup with `rc-trigger-popup-content` when multiple children\n\nexport function generateTrigger(PortalComponent = Portal) {\n  const Trigger = /*#__PURE__*/React.forwardRef((props, ref) => {\n    const {\n      prefixCls = 'rc-trigger-popup',\n      children,\n      // Action\n      action = 'hover',\n      showAction,\n      hideAction,\n      // Open\n      popupVisible,\n      defaultPopupVisible,\n      onOpenChange,\n      afterOpenChange,\n      onPopupVisibleChange,\n      afterPopupVisibleChange,\n      // Delay\n      mouseEnterDelay,\n      mouseLeaveDelay = 0.1,\n      focusDelay,\n      blurDelay,\n      // Mask\n      mask,\n      maskClosable = true,\n      // Portal\n      getPopupContainer,\n      forceRender,\n      autoDestroy,\n      // Popup\n      popup,\n      popupClassName,\n      uniqueContainerClassName,\n      uniqueContainerStyle,\n      popupStyle,\n      popupPlacement,\n      builtinPlacements = {},\n      popupAlign,\n      zIndex,\n      stretch,\n      getPopupClassNameFromAlign,\n      fresh,\n      unique,\n      alignPoint,\n      onPopupClick,\n      onPopupAlign,\n      // Arrow\n      arrow,\n      // Motion\n      popupMotion,\n      maskMotion,\n      // Private\n      mobile,\n      ...restProps\n    } = props;\n    const mergedAutoDestroy = autoDestroy || false;\n    const openUncontrolled = popupVisible === undefined;\n\n    // =========================== Mobile ===========================\n    const isMobile = !!mobile;\n\n    // ========================== Context ===========================\n    const subPopupElements = React.useRef({});\n    const parentContext = React.useContext(TriggerContext);\n    const context = React.useMemo(() => {\n      return {\n        registerSubPopup: (id, subPopupEle) => {\n          subPopupElements.current[id] = subPopupEle;\n          parentContext?.registerSubPopup(id, subPopupEle);\n        }\n      };\n    }, [parentContext]);\n\n    // ======================== UniqueContext =========================\n    const uniqueContext = React.useContext(UniqueContext);\n\n    // =========================== Popup ============================\n    const id = useId();\n    const [popupEle, setPopupEle] = React.useState(null);\n\n    // Used for forwardRef popup. Not use internal\n    const externalPopupRef = React.useRef(null);\n    const setPopupRef = useEvent(node => {\n      externalPopupRef.current = node;\n      if (isDOM(node) && popupEle !== node) {\n        setPopupEle(node);\n      }\n      parentContext?.registerSubPopup(id, node);\n    });\n\n    // =========================== Target ===========================\n    // Use state to control here since `useRef` update not trigger render\n    const [targetEle, setTargetEle] = React.useState(null);\n\n    // Used for forwardRef target. Not use internal\n    const externalForwardRef = React.useRef(null);\n    const setTargetRef = useEvent(node => {\n      const domNode = getDOM(node);\n      if (isDOM(domNode) && targetEle !== domNode) {\n        setTargetEle(domNode);\n        externalForwardRef.current = domNode;\n      }\n    });\n    const cloneProps = {};\n    const inPopupOrChild = useEvent(ele => {\n      const childDOM = targetEle;\n      return childDOM?.contains(ele) || getShadowRoot(childDOM)?.host === ele || ele === childDOM || popupEle?.contains(ele) || getShadowRoot(popupEle)?.host === ele || ele === popupEle || Object.values(subPopupElements.current).some(subPopupEle => subPopupEle?.contains(ele) || ele === subPopupEle);\n    });\n\n    // =========================== Arrow ============================\n    const innerArrow = arrow ? {\n      // true and Object likely\n      ...(arrow !== true ? arrow : {})\n    } : null;\n\n    // ============================ Open ============================\n    const [internalOpen, setInternalOpen] = useControlledState(defaultPopupVisible || false, popupVisible);\n    const mergedOpen = internalOpen || false;\n\n    // ========================== Children ==========================\n    const child = React.useMemo(() => {\n      const nextChild = typeof children === 'function' ? children({\n        open: mergedOpen\n      }) : children;\n      return React.Children.only(nextChild);\n    }, [children, mergedOpen]);\n    const originChildProps = child?.props || {};\n\n    // Support ref\n    const isOpen = useEvent(() => mergedOpen);\n\n    // Extract common options for UniqueProvider\n    const getUniqueOptions = useEvent((delay = 0) => ({\n      popup,\n      target: targetEle,\n      delay,\n      prefixCls,\n      popupClassName,\n      uniqueContainerClassName,\n      uniqueContainerStyle,\n      popupStyle,\n      popupPlacement,\n      builtinPlacements,\n      popupAlign,\n      zIndex,\n      mask,\n      maskClosable,\n      popupMotion,\n      maskMotion,\n      arrow: innerArrow,\n      getPopupContainer,\n      getPopupClassNameFromAlign,\n      id,\n      onEsc\n    }));\n\n    // Handle controlled state changes for UniqueProvider\n    // Only sync to UniqueProvider when it's controlled mode\n    // If there is a parentContext, don't call uniqueContext methods\n    useLayoutEffect(() => {\n      if (uniqueContext && unique && targetEle && !openUncontrolled && !parentContext) {\n        if (mergedOpen) {\n          uniqueContext.show(getUniqueOptions(mouseEnterDelay), isOpen);\n        } else {\n          uniqueContext.hide(mouseLeaveDelay);\n        }\n      }\n    }, [mergedOpen, targetEle]);\n    const openRef = React.useRef(mergedOpen);\n    openRef.current = mergedOpen;\n    const internalTriggerOpen = useEvent(nextOpen => {\n      flushSync(() => {\n        if (mergedOpen !== nextOpen) {\n          setInternalOpen(nextOpen);\n          onOpenChange?.(nextOpen);\n          onPopupVisibleChange?.(nextOpen);\n        }\n      });\n    });\n\n    // Trigger for delay\n    const delayInvoke = useDelay();\n    const triggerOpen = (nextOpen, delay = 0) => {\n      // If it's controlled mode, always use internal trigger logic\n      // UniqueProvider will be synced through useLayoutEffect\n      if (popupVisible !== undefined) {\n        delayInvoke(() => {\n          internalTriggerOpen(nextOpen);\n        }, delay);\n        return;\n      }\n\n      // If UniqueContext exists and not controlled, pass delay to Provider instead of handling it internally\n      // If there is a parentContext, don't call uniqueContext methods\n      if (uniqueContext && unique && openUncontrolled && !parentContext) {\n        if (nextOpen) {\n          uniqueContext.show(getUniqueOptions(delay), isOpen);\n        } else {\n          uniqueContext.hide(delay);\n        }\n        return;\n      }\n      delayInvoke(() => {\n        internalTriggerOpen(nextOpen);\n      }, delay);\n    };\n    function onEsc({\n      top\n    }) {\n      if (top) {\n        triggerOpen(false);\n      }\n    }\n\n    // ========================== Motion ============================\n    const [inMotion, setInMotion] = React.useState(false);\n    useLayoutEffect(firstMount => {\n      if (!firstMount || mergedOpen) {\n        setInMotion(true);\n      }\n    }, [mergedOpen]);\n    const [motionPrepareResolve, setMotionPrepareResolve] = React.useState(null);\n\n    // =========================== Align ============================\n    const [mousePos, setMousePos] = React.useState(null);\n    const setMousePosByEvent = event => {\n      setMousePos([event.clientX, event.clientY]);\n    };\n    const [ready, offsetX, offsetY, offsetR, offsetB, arrowX, arrowY, scaleX, scaleY, alignInfo, onAlign] = useAlign(mergedOpen, popupEle, alignPoint && mousePos !== null ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign, isMobile);\n    const [showActions, hideActions] = useAction(action, showAction, hideAction);\n    const clickToShow = showActions.has('click');\n    const clickToHide = hideActions.has('click') || hideActions.has('contextMenu');\n    const triggerAlign = useEvent(() => {\n      if (!inMotion) {\n        onAlign();\n      }\n    });\n    const onScroll = () => {\n      if (openRef.current && alignPoint && clickToHide) {\n        triggerOpen(false);\n      }\n    };\n    useWatch(mergedOpen, targetEle, popupEle, triggerAlign, onScroll);\n    useLayoutEffect(() => {\n      triggerAlign();\n    }, [mousePos, popupPlacement]);\n\n    // When no builtinPlacements and popupAlign changed\n    useLayoutEffect(() => {\n      if (mergedOpen && !builtinPlacements?.[popupPlacement]) {\n        triggerAlign();\n      }\n    }, [JSON.stringify(popupAlign)]);\n    const alignedClassName = React.useMemo(() => {\n      const baseClassName = getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint);\n      return clsx(baseClassName, getPopupClassNameFromAlign?.(alignInfo));\n    }, [alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint]);\n\n    // ============================ Refs ============================\n    React.useImperativeHandle(ref, () => ({\n      nativeElement: externalForwardRef.current,\n      popupElement: externalPopupRef.current,\n      forceAlign: triggerAlign\n    }));\n\n    // ========================== Stretch ===========================\n    const [targetWidth, setTargetWidth] = React.useState(0);\n    const [targetHeight, setTargetHeight] = React.useState(0);\n    const syncTargetSize = () => {\n      if (stretch && targetEle) {\n        const rect = targetEle.getBoundingClientRect();\n        setTargetWidth(rect.width);\n        setTargetHeight(rect.height);\n      }\n    };\n    const onTargetResize = () => {\n      syncTargetSize();\n      triggerAlign();\n    };\n\n    // ========================== Motion ============================\n    const onVisibleChanged = visible => {\n      setInMotion(false);\n      onAlign();\n      afterOpenChange?.(visible);\n      afterPopupVisibleChange?.(visible);\n    };\n\n    // We will trigger align when motion is in prepare\n    const onPrepare = () => new Promise(resolve => {\n      syncTargetSize();\n      setMotionPrepareResolve(() => resolve);\n    });\n    useLayoutEffect(() => {\n      if (motionPrepareResolve) {\n        onAlign();\n        motionPrepareResolve();\n        setMotionPrepareResolve(null);\n      }\n    }, [motionPrepareResolve]);\n\n    // =========================== Action ===========================\n    /**\n     * Util wrapper for trigger action\n     * @param eventName  Listen event name\n     * @param nextOpen  Next open state after trigger\n     * @param delay Delay to trigger open change\n     * @param callback Callback if current event need additional action\n     * @param ignoreCheck  Ignore current event if check return true\n     */\n    function wrapperAction(eventName, nextOpen, delay, callback, ignoreCheck) {\n      cloneProps[eventName] = (event, ...args) => {\n        if (!ignoreCheck || !ignoreCheck()) {\n          callback?.(event);\n          triggerOpen(nextOpen, delay);\n        }\n\n        // Pass to origin\n        originChildProps[eventName]?.(event, ...args);\n      };\n    }\n\n    // ======================= Action: Touch ========================\n    const touchToShow = showActions.has('touch');\n    const touchToHide = hideActions.has('touch');\n\n    /** Used for prevent `hover` event conflict with mobile env */\n    const touchedRef = React.useRef(false);\n    if (touchToShow || touchToHide) {\n      cloneProps.onTouchStart = (...args) => {\n        touchedRef.current = true;\n        if (openRef.current && touchToHide) {\n          triggerOpen(false);\n        } else if (!openRef.current && touchToShow) {\n          triggerOpen(true);\n        }\n\n        // Pass to origin\n        originChildProps.onTouchStart?.(...args);\n      };\n    }\n\n    // ======================= Action: Click ========================\n    if (clickToShow || clickToHide) {\n      cloneProps.onClick = (event, ...args) => {\n        if (openRef.current && clickToHide) {\n          triggerOpen(false);\n        } else if (!openRef.current && clickToShow) {\n          setMousePosByEvent(event);\n          triggerOpen(true);\n        }\n\n        // Pass to origin\n        originChildProps.onClick?.(event, ...args);\n        touchedRef.current = false;\n      };\n    }\n\n    // Click to hide is special action since click popup element should not hide\n    const onPopupPointerDown = useWinClick(mergedOpen, clickToHide || touchToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen);\n\n    // ======================= Action: Hover ========================\n    const hoverToShow = showActions.has('hover');\n    const hoverToHide = hideActions.has('hover');\n    let onPopupMouseEnter;\n    let onPopupMouseLeave;\n    const ignoreMouseTrigger = () => {\n      return touchedRef.current;\n    };\n    if (hoverToShow) {\n      const onMouseEnterCallback = event => {\n        setMousePosByEvent(event);\n      };\n\n      // Compatible with old browser which not support pointer event\n      wrapperAction('onMouseEnter', true, mouseEnterDelay, onMouseEnterCallback, ignoreMouseTrigger);\n      wrapperAction('onPointerEnter', true, mouseEnterDelay, onMouseEnterCallback, ignoreMouseTrigger);\n      onPopupMouseEnter = event => {\n        // Only trigger re-open when popup is visible\n        if ((mergedOpen || inMotion) && popupEle?.contains(event.target)) {\n          triggerOpen(true, mouseEnterDelay);\n        }\n      };\n\n      // Align Point\n      if (alignPoint) {\n        cloneProps.onMouseMove = event => {\n          originChildProps.onMouseMove?.(event);\n        };\n      }\n    }\n    if (hoverToHide) {\n      wrapperAction('onMouseLeave', false, mouseLeaveDelay, undefined, ignoreMouseTrigger);\n      wrapperAction('onPointerLeave', false, mouseLeaveDelay, undefined, ignoreMouseTrigger);\n      onPopupMouseLeave = () => {\n        triggerOpen(false, mouseLeaveDelay);\n      };\n    }\n\n    // ======================= Action: Focus ========================\n    if (showActions.has('focus')) {\n      wrapperAction('onFocus', true, focusDelay);\n    }\n    if (hideActions.has('focus')) {\n      wrapperAction('onBlur', false, blurDelay);\n    }\n\n    // ==================== Action: ContextMenu =====================\n    if (showActions.has('contextMenu')) {\n      cloneProps.onContextMenu = (event, ...args) => {\n        if (openRef.current && hideActions.has('contextMenu')) {\n          triggerOpen(false);\n        } else {\n          setMousePosByEvent(event);\n          triggerOpen(true);\n        }\n        event.preventDefault();\n\n        // Pass to origin\n        originChildProps.onContextMenu?.(event, ...args);\n      };\n    }\n\n    // ============================ Perf ============================\n    const rendedRef = React.useRef(false);\n    rendedRef.current ||= forceRender || mergedOpen || inMotion;\n\n    // =========================== Render ===========================\n    const mergedChildrenProps = {\n      ...originChildProps,\n      ...cloneProps\n    };\n\n    // Pass props into cloneProps for nest usage\n    const passedProps = {};\n    const passedEventList = ['onContextMenu', 'onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter', 'onMouseLeave', 'onFocus', 'onBlur'];\n    passedEventList.forEach(eventName => {\n      if (restProps[eventName]) {\n        passedProps[eventName] = (...args) => {\n          mergedChildrenProps[eventName]?.(...args);\n          restProps[eventName](...args);\n        };\n      }\n    });\n    const arrowPos = {\n      x: arrowX,\n      y: arrowY\n    };\n\n    // =================== Resize Observer ===================\n    // Use hook to observe target element resize\n    // Pass targetEle directly instead of a function so the hook will re-observe when target changes\n    useResizeObserver(mergedOpen, targetEle, onTargetResize);\n\n    // Compose refs\n    const mergedRef = useComposeRef(setTargetRef, getNodeRef(child));\n\n    // Child Node\n    const triggerNode = /*#__PURE__*/React.cloneElement(child, {\n      ...mergedChildrenProps,\n      ...passedProps,\n      ref: mergedRef\n    });\n\n    // Render\n    return /*#__PURE__*/React.createElement(React.Fragment, null, triggerNode, rendedRef.current && (!uniqueContext || !unique) && /*#__PURE__*/React.createElement(TriggerContext.Provider, {\n      value: context\n    }, /*#__PURE__*/React.createElement(Popup, {\n      portal: PortalComponent,\n      ref: setPopupRef,\n      prefixCls: prefixCls,\n      popup: popup,\n      className: clsx(popupClassName, !isMobile && alignedClassName),\n      style: popupStyle,\n      target: targetEle,\n      onMouseEnter: onPopupMouseEnter,\n      onMouseLeave: onPopupMouseLeave\n      // https://github.com/ant-design/ant-design/issues/43924\n      ,\n      onPointerEnter: onPopupMouseEnter,\n      zIndex: zIndex\n      // Open\n      ,\n      open: mergedOpen,\n      keepDom: inMotion,\n      fresh: fresh\n      // Click\n      ,\n      onClick: onPopupClick,\n      onPointerDownCapture: onPopupPointerDown\n      // Mask\n      ,\n      mask: mask\n      // Motion\n      ,\n      motion: popupMotion,\n      maskMotion: maskMotion,\n      onVisibleChanged: onVisibleChanged,\n      onPrepare: onPrepare\n      // Portal\n      ,\n      forceRender: forceRender,\n      autoDestroy: mergedAutoDestroy,\n      getPopupContainer: getPopupContainer,\n      onEsc: onEsc\n      // Arrow\n      ,\n      align: alignInfo,\n      arrow: innerArrow,\n      arrowPos: arrowPos\n      // Align\n      ,\n      ready: ready,\n      offsetX: offsetX,\n      offsetY: offsetY,\n      offsetR: offsetR,\n      offsetB: offsetB,\n      onAlign: triggerAlign\n      // Stretch\n      ,\n      stretch: stretch,\n      targetWidth: targetWidth / scaleX,\n      targetHeight: targetHeight / scaleY\n      // Mobile\n      ,\n      mobile: mobile\n    })));\n  });\n  if (process.env.NODE_ENV !== 'production') {\n    Trigger.displayName = 'Trigger';\n  }\n  return Trigger;\n}\nexport default generateTrigger(Portal);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}