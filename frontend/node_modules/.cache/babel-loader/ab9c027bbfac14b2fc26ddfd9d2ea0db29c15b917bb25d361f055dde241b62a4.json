{"ast":null,"code":"function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n// TODO: Fully accessibility support\n// Reference: https://www.w3.org/WAI/ARIA/apg/patterns/treeview\n\nimport { clsx } from 'clsx';\nimport pickAttrs from \"@rc-component/util/es/pickAttrs\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { TreeContext } from \"./contextTypes\";\nimport DropIndicator from \"./DropIndicator\";\nimport NodeList, { MOTION_KEY, MotionEntity } from \"./NodeList\";\nimport TreeNode from \"./TreeNode\";\nimport { arrAdd, arrDel, calcDropPosition, calcSelectedKeys, conductExpandParent, getDragChildrenKeys, parseCheckedKeys, posToArr } from \"./util\";\nimport { conductCheck } from \"./utils/conductUtil\";\nimport getEntity from \"./utils/keyUtil\";\nimport { convertDataToEntities, convertNodePropsToEventData, convertTreeToData, fillFieldNames, flattenTreeData, getTreeNodeProps, isLeafNode, warningWithoutKey } from \"./utils/treeUtil\";\nconst MAX_RETRY_TIMES = 10;\nclass Tree extends React.Component {\n  static defaultProps = {\n    prefixCls: 'rc-tree',\n    showLine: false,\n    showIcon: true,\n    selectable: true,\n    multiple: false,\n    checkable: false,\n    disabled: false,\n    checkStrictly: false,\n    draggable: false,\n    defaultExpandParent: true,\n    autoExpandParent: false,\n    defaultExpandAll: false,\n    defaultExpandedKeys: [],\n    defaultCheckedKeys: [],\n    defaultSelectedKeys: [],\n    dropIndicatorRender: DropIndicator,\n    allowDrop: () => true,\n    expandAction: false\n  };\n  static TreeNode = TreeNode;\n  destroyed = false;\n  delayedDragEnterLogic;\n  loadingRetryTimes = {};\n  state = {\n    keyEntities: {},\n    indent: null,\n    selectedKeys: [],\n    checkedKeys: [],\n    halfCheckedKeys: [],\n    loadedKeys: [],\n    loadingKeys: [],\n    expandedKeys: [],\n    draggingNodeKey: null,\n    dragChildrenKeys: [],\n    // dropTargetKey is the key of abstract-drop-node\n    // the abstract-drop-node is the real drop node when drag and drop\n    // not the DOM drag over node\n    dropTargetKey: null,\n    dropPosition: null,\n    // the drop position of abstract-drop-node, inside 0, top -1, bottom 1\n    dropContainerKey: null,\n    // the container key of abstract-drop-node if dropPosition is -1 or 1\n    dropLevelOffset: null,\n    // the drop level offset of abstract-drag-over-node\n    dropTargetPos: null,\n    // the pos of abstract-drop-node\n    dropAllowed: true,\n    // if drop to abstract-drop-node is allowed\n    // the abstract-drag-over-node\n    // if mouse is on the bottom of top dom node or no the top of the bottom dom node\n    // abstract-drag-over-node is the top node\n    dragOverNodeKey: null,\n    treeData: [],\n    flattenNodes: [],\n    activeKey: null,\n    listChanging: false,\n    prevProps: null,\n    fieldNames: fillFieldNames()\n  };\n  dragStartMousePosition = null;\n  dragNodeProps = null;\n  currentMouseOverDroppableNodeKey = null;\n  listRef = /*#__PURE__*/React.createRef();\n  componentDidMount() {\n    this.destroyed = false;\n    this.onUpdated();\n  }\n  componentDidUpdate() {\n    this.onUpdated();\n  }\n  onUpdated() {\n    const {\n      activeKey,\n      itemScrollOffset = 0\n    } = this.props;\n    if (activeKey !== undefined && activeKey !== this.state.activeKey) {\n      this.setState({\n        activeKey\n      });\n      if (activeKey !== null) {\n        this.scrollTo({\n          key: activeKey,\n          offset: itemScrollOffset\n        });\n      }\n    }\n  }\n  componentWillUnmount() {\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n    this.destroyed = true;\n  }\n  static getDerivedStateFromProps(props, prevState) {\n    const {\n      prevProps\n    } = prevState;\n    const newState = {\n      prevProps: props\n    };\n    function needSync(name) {\n      return !prevProps && props.hasOwnProperty(name) || prevProps && prevProps[name] !== props[name];\n    }\n\n    // ================== Tree Node ==================\n    let treeData;\n\n    // fieldNames\n    let {\n      fieldNames\n    } = prevState;\n    if (needSync('fieldNames')) {\n      fieldNames = fillFieldNames(props.fieldNames);\n      newState.fieldNames = fieldNames;\n    }\n\n    // Check if `treeData` or `children` changed and save into the state.\n    if (needSync('treeData')) {\n      ({\n        treeData\n      } = props);\n    } else if (needSync('children')) {\n      warning(false, '`children` of Tree is deprecated. Please use `treeData` instead.');\n      treeData = convertTreeToData(props.children);\n    }\n\n    // Save flatten nodes info and convert `treeData` into keyEntities\n    if (treeData) {\n      newState.treeData = treeData;\n      const entitiesMap = convertDataToEntities(treeData, {\n        fieldNames\n      });\n      newState.keyEntities = {\n        [MOTION_KEY]: MotionEntity,\n        ...entitiesMap.keyEntities\n      };\n\n      // Warning if treeNode not provide key\n      if (process.env.NODE_ENV !== 'production') {\n        warningWithoutKey(treeData, fieldNames);\n      }\n    }\n    const keyEntities = newState.keyEntities || prevState.keyEntities;\n\n    // ================ expandedKeys =================\n    if (needSync('expandedKeys') || prevProps && needSync('autoExpandParent')) {\n      newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;\n    } else if (!prevProps && props.defaultExpandAll) {\n      const cloneKeyEntities = {\n        ...keyEntities\n      };\n      delete cloneKeyEntities[MOTION_KEY];\n\n      // Only take the key who has the children to enhance the performance\n      const nextExpandedKeys = [];\n      Object.keys(cloneKeyEntities).forEach(key => {\n        const entity = cloneKeyEntities[key];\n        if (entity.children && entity.children.length) {\n          nextExpandedKeys.push(entity.key);\n        }\n      });\n      newState.expandedKeys = nextExpandedKeys;\n    } else if (!prevProps && props.defaultExpandedKeys) {\n      newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;\n    }\n    if (!newState.expandedKeys) {\n      delete newState.expandedKeys;\n    }\n\n    // ================ flattenNodes =================\n    if (treeData || newState.expandedKeys) {\n      const flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);\n      newState.flattenNodes = flattenNodes;\n    }\n\n    // ================ selectedKeys =================\n    if (props.selectable) {\n      if (needSync('selectedKeys')) {\n        newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);\n      } else if (!prevProps && props.defaultSelectedKeys) {\n        newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);\n      }\n    }\n\n    // ================= checkedKeys =================\n    if (props.checkable) {\n      let checkedKeyEntity;\n      if (needSync('checkedKeys')) {\n        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};\n      } else if (!prevProps && props.defaultCheckedKeys) {\n        checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};\n      } else if (treeData) {\n        // If `treeData` changed, we also need check it\n        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {\n          checkedKeys: prevState.checkedKeys,\n          halfCheckedKeys: prevState.halfCheckedKeys\n        };\n      }\n      if (checkedKeyEntity) {\n        let {\n          checkedKeys = [],\n          halfCheckedKeys = []\n        } = checkedKeyEntity;\n        if (!props.checkStrictly) {\n          const conductKeys = conductCheck(checkedKeys, true, keyEntities);\n          ({\n            checkedKeys,\n            halfCheckedKeys\n          } = conductKeys);\n        }\n        newState.checkedKeys = checkedKeys;\n        newState.halfCheckedKeys = halfCheckedKeys;\n      }\n    }\n\n    // ================= loadedKeys ==================\n    if (needSync('loadedKeys')) {\n      newState.loadedKeys = props.loadedKeys;\n    }\n    return newState;\n  }\n  onNodeDragStart = (event, nodeProps) => {\n    const {\n      expandedKeys,\n      keyEntities\n    } = this.state;\n    const {\n      onDragStart\n    } = this.props;\n    const {\n      eventKey\n    } = nodeProps;\n    this.dragNodeProps = nodeProps;\n    this.dragStartMousePosition = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    const newExpandedKeys = arrDel(expandedKeys, eventKey);\n    this.setState({\n      draggingNodeKey: eventKey,\n      dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),\n      indent: this.listRef.current.getIndentWidth()\n    });\n    this.setExpandedKeys(newExpandedKeys);\n    window.addEventListener('dragend', this.onWindowDragEnd);\n    onDragStart?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n\n  /**\n   * [Legacy] Select handler is smaller than node,\n   * so that this will trigger when drag enter node or select handler.\n   * This is a little tricky if customize css without padding.\n   * Better for use mouse move event to refresh drag state.\n   * But let's just keep it to avoid event trigger logic change.\n   */\n  onNodeDragEnter = (event, nodeProps) => {\n    const {\n      expandedKeys,\n      keyEntities,\n      dragChildrenKeys,\n      flattenNodes,\n      indent\n    } = this.state;\n    const {\n      onDragEnter,\n      onExpand,\n      allowDrop,\n      direction\n    } = this.props;\n    const {\n      pos,\n      eventKey\n    } = nodeProps;\n\n    // record the key of node which is latest entered, used in dragleave event.\n    if (this.currentMouseOverDroppableNodeKey !== eventKey) {\n      this.currentMouseOverDroppableNodeKey = eventKey;\n    }\n    if (!this.dragNodeProps) {\n      this.resetDragState();\n      return;\n    }\n    const {\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed,\n      dragOverNodeKey\n    } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);\n    if (\n    // don't allow drop inside its children\n    dragChildrenKeys.includes(dropTargetKey) ||\n    // don't allow drop when drop is not allowed caculated by calcDropPosition\n    !dropAllowed) {\n      this.resetDragState();\n      return;\n    }\n\n    // Side effect for delay drag\n    if (!this.delayedDragEnterLogic) {\n      this.delayedDragEnterLogic = {};\n    }\n    Object.keys(this.delayedDragEnterLogic).forEach(key => {\n      clearTimeout(this.delayedDragEnterLogic[key]);\n    });\n    if (this.dragNodeProps.eventKey !== nodeProps.eventKey) {\n      // hoist expand logic here\n      // since if logic is on the bottom\n      // it will be blocked by abstract dragover node check\n      //   => if you dragenter from top, you mouse will still be consider as in the top node\n      event.persist();\n      this.delayedDragEnterLogic[pos] = window.setTimeout(() => {\n        if (this.state.draggingNodeKey === null) {\n          return;\n        }\n        let newExpandedKeys = [...expandedKeys];\n        const entity = getEntity(keyEntities, nodeProps.eventKey);\n        if (entity && (entity.children || []).length) {\n          newExpandedKeys = arrAdd(expandedKeys, nodeProps.eventKey);\n        }\n        if (!this.props.hasOwnProperty('expandedKeys')) {\n          this.setExpandedKeys(newExpandedKeys);\n        }\n        onExpand?.(newExpandedKeys, {\n          node: convertNodePropsToEventData(nodeProps),\n          expanded: true,\n          nativeEvent: event.nativeEvent\n        });\n      }, 800);\n    }\n\n    // Skip if drag node is self\n    if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {\n      this.resetDragState();\n      return;\n    }\n\n    // Update drag over node and drag state\n    this.setState({\n      dragOverNodeKey,\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed\n    });\n    onDragEnter?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps),\n      expandedKeys\n    });\n  };\n  onNodeDragOver = (event, nodeProps) => {\n    const {\n      dragChildrenKeys,\n      flattenNodes,\n      keyEntities,\n      expandedKeys,\n      indent\n    } = this.state;\n    const {\n      onDragOver,\n      allowDrop,\n      direction\n    } = this.props;\n    if (!this.dragNodeProps) {\n      return;\n    }\n    const {\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed,\n      dragOverNodeKey\n    } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);\n    if (dragChildrenKeys.includes(dropTargetKey) || !dropAllowed) {\n      // don't allow drop inside its children\n      // don't allow drop when drop is not allowed calculated by calcDropPosition\n      return;\n    }\n\n    // Update drag position\n\n    if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {\n      if (!(this.state.dropPosition === null && this.state.dropLevelOffset === null && this.state.dropTargetKey === null && this.state.dropContainerKey === null && this.state.dropTargetPos === null && this.state.dropAllowed === false && this.state.dragOverNodeKey === null)) {\n        this.resetDragState();\n      }\n    } else if (!(dropPosition === this.state.dropPosition && dropLevelOffset === this.state.dropLevelOffset && dropTargetKey === this.state.dropTargetKey && dropContainerKey === this.state.dropContainerKey && dropTargetPos === this.state.dropTargetPos && dropAllowed === this.state.dropAllowed && dragOverNodeKey === this.state.dragOverNodeKey)) {\n      this.setState({\n        dropPosition,\n        dropLevelOffset,\n        dropTargetKey,\n        dropContainerKey,\n        dropTargetPos,\n        dropAllowed,\n        dragOverNodeKey\n      });\n    }\n    onDragOver?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n  onNodeDragLeave = (event, nodeProps) => {\n    // if it is outside the droppable area\n    // currentMouseOverDroppableNodeKey will be updated in dragenter event when into another droppable receiver.\n    if (this.currentMouseOverDroppableNodeKey === nodeProps.eventKey && !event.currentTarget.contains(event.relatedTarget)) {\n      this.resetDragState();\n      this.currentMouseOverDroppableNodeKey = null;\n    }\n    const {\n      onDragLeave\n    } = this.props;\n    onDragLeave?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n\n  // since stopPropagation() is called in treeNode\n  // if onWindowDrag is called, whice means state is keeped, drag state should be cleared\n  onWindowDragEnd = event => {\n    this.onNodeDragEnd(event, null, true);\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n  };\n\n  // if onNodeDragEnd is called, onWindowDragEnd won't be called since stopPropagation() is called\n  onNodeDragEnd = (event, nodeProps) => {\n    const {\n      onDragEnd\n    } = this.props;\n    this.setState({\n      dragOverNodeKey: null\n    });\n    this.cleanDragState();\n    onDragEnd?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n    this.dragNodeProps = null;\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n  };\n  onNodeDrop = (event, _, outsideTree = false) => {\n    const {\n      dragChildrenKeys,\n      dropPosition,\n      dropTargetKey,\n      dropTargetPos,\n      dropAllowed\n    } = this.state;\n    if (!dropAllowed) {\n      return;\n    }\n    const {\n      onDrop\n    } = this.props;\n    this.setState({\n      dragOverNodeKey: null\n    });\n    this.cleanDragState();\n    if (dropTargetKey === null) return;\n    const abstractDropNodeProps = {\n      ...getTreeNodeProps(dropTargetKey, this.getTreeNodeRequiredProps()),\n      active: this.getActiveItem()?.key === dropTargetKey,\n      data: getEntity(this.state.keyEntities, dropTargetKey).node\n    };\n    const dropToChild = dragChildrenKeys.includes(dropTargetKey);\n    warning(!dropToChild, \"Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.\");\n    const posArr = posToArr(dropTargetPos);\n    const dropResult = {\n      event,\n      node: convertNodePropsToEventData(abstractDropNodeProps),\n      dragNode: this.dragNodeProps ? convertNodePropsToEventData(this.dragNodeProps) : null,\n      dragNodesKeys: [this.dragNodeProps.eventKey].concat(dragChildrenKeys),\n      dropToGap: dropPosition !== 0,\n      dropPosition: dropPosition + Number(posArr[posArr.length - 1])\n    };\n    if (!outsideTree) {\n      onDrop?.(dropResult);\n    }\n    this.dragNodeProps = null;\n  };\n  resetDragState() {\n    this.setState({\n      dragOverNodeKey: null,\n      dropPosition: null,\n      dropLevelOffset: null,\n      dropTargetKey: null,\n      dropContainerKey: null,\n      dropTargetPos: null,\n      dropAllowed: false\n    });\n  }\n  cleanDragState = () => {\n    const {\n      draggingNodeKey\n    } = this.state;\n    if (draggingNodeKey !== null) {\n      this.setState({\n        draggingNodeKey: null,\n        dropPosition: null,\n        dropContainerKey: null,\n        dropTargetKey: null,\n        dropLevelOffset: null,\n        dropAllowed: true,\n        dragOverNodeKey: null\n      });\n    }\n    this.dragStartMousePosition = null;\n    this.currentMouseOverDroppableNodeKey = null;\n  };\n  triggerExpandActionExpand = (e, treeNode) => {\n    const {\n      expandedKeys,\n      flattenNodes\n    } = this.state;\n    const {\n      expanded,\n      key,\n      isLeaf\n    } = treeNode;\n    if (isLeaf || e.shiftKey || e.metaKey || e.ctrlKey) {\n      return;\n    }\n    const node = flattenNodes.filter(nodeItem => nodeItem.key === key)[0];\n    const eventNode = convertNodePropsToEventData({\n      ...getTreeNodeProps(key, this.getTreeNodeRequiredProps()),\n      data: node.data\n    });\n    this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));\n    this.onNodeExpand(e, eventNode);\n  };\n  onNodeClick = (e, treeNode) => {\n    const {\n      onClick,\n      expandAction\n    } = this.props;\n    if (expandAction === 'click') {\n      this.triggerExpandActionExpand(e, treeNode);\n    }\n    onClick?.(e, treeNode);\n  };\n  onNodeDoubleClick = (e, treeNode) => {\n    const {\n      onDoubleClick,\n      expandAction\n    } = this.props;\n    if (expandAction === 'doubleClick') {\n      this.triggerExpandActionExpand(e, treeNode);\n    }\n    onDoubleClick?.(e, treeNode);\n  };\n  onNodeSelect = (e, treeNode) => {\n    let {\n      selectedKeys\n    } = this.state;\n    const {\n      keyEntities,\n      fieldNames\n    } = this.state;\n    const {\n      onSelect,\n      multiple\n    } = this.props;\n    const {\n      selected\n    } = treeNode;\n    const key = treeNode[fieldNames.key];\n    const targetSelected = !selected;\n\n    // Update selected keys\n    if (!targetSelected) {\n      selectedKeys = arrDel(selectedKeys, key);\n    } else if (!multiple) {\n      selectedKeys = [key];\n    } else {\n      selectedKeys = arrAdd(selectedKeys, key);\n    }\n\n    // [Legacy] Not found related usage in doc or upper libs\n    const selectedNodes = selectedKeys.map(selectedKey => {\n      const entity = getEntity(keyEntities, selectedKey);\n      return entity ? entity.node : null;\n    }).filter(Boolean);\n    this.setUncontrolledState({\n      selectedKeys\n    });\n    onSelect?.(selectedKeys, {\n      event: 'select',\n      selected: targetSelected,\n      node: treeNode,\n      selectedNodes,\n      nativeEvent: e.nativeEvent\n    });\n  };\n  onNodeCheck = (e, treeNode, checked) => {\n    const {\n      keyEntities,\n      checkedKeys: oriCheckedKeys,\n      halfCheckedKeys: oriHalfCheckedKeys\n    } = this.state;\n    const {\n      checkStrictly,\n      onCheck\n    } = this.props;\n    const {\n      key\n    } = treeNode;\n\n    // Prepare trigger arguments\n    let checkedObj;\n    const eventObj = {\n      event: 'check',\n      node: treeNode,\n      checked,\n      nativeEvent: e.nativeEvent\n    };\n    if (checkStrictly) {\n      const checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);\n      const halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);\n      checkedObj = {\n        checked: checkedKeys,\n        halfChecked: halfCheckedKeys\n      };\n      eventObj.checkedNodes = checkedKeys.map(checkedKey => getEntity(keyEntities, checkedKey)).filter(Boolean).map(entity => entity.node);\n      this.setUncontrolledState({\n        checkedKeys\n      });\n    } else {\n      // Always fill first\n      let {\n        checkedKeys,\n        halfCheckedKeys\n      } = conductCheck([...oriCheckedKeys, key], true, keyEntities);\n\n      // If remove, we do it again to correction\n      if (!checked) {\n        const keySet = new Set(checkedKeys);\n        keySet.delete(key);\n        ({\n          checkedKeys,\n          halfCheckedKeys\n        } = conductCheck(Array.from(keySet), {\n          checked: false,\n          halfCheckedKeys\n        }, keyEntities));\n      }\n      checkedObj = checkedKeys;\n\n      // [Legacy] This is used for `rc-tree-select`\n      eventObj.checkedNodes = [];\n      eventObj.checkedNodesPositions = [];\n      eventObj.halfCheckedKeys = halfCheckedKeys;\n      checkedKeys.forEach(checkedKey => {\n        const entity = getEntity(keyEntities, checkedKey);\n        if (!entity) return;\n        const {\n          node,\n          pos\n        } = entity;\n        eventObj.checkedNodes.push(node);\n        eventObj.checkedNodesPositions.push({\n          node,\n          pos\n        });\n      });\n      this.setUncontrolledState({\n        checkedKeys\n      }, false, {\n        halfCheckedKeys\n      });\n    }\n    onCheck?.(checkedObj, eventObj);\n  };\n  onNodeLoad = treeNode => {\n    const {\n      key\n    } = treeNode;\n    const {\n      keyEntities\n    } = this.state;\n\n    // Skip if has children already\n    const entity = getEntity(keyEntities, key);\n    if (entity?.children?.length) {\n      return;\n    }\n    const loadPromise = new Promise((resolve, reject) => {\n      // We need to get the latest state of loading/loaded keys\n      this.setState(({\n        loadedKeys = [],\n        loadingKeys = []\n      }) => {\n        const {\n          loadData,\n          onLoad\n        } = this.props;\n        if (!loadData || loadedKeys.includes(key) || loadingKeys.includes(key)) {\n          return null;\n        }\n\n        // Process load data\n        const promise = loadData(treeNode);\n        promise.then(() => {\n          const {\n            loadedKeys: currentLoadedKeys\n          } = this.state;\n          const newLoadedKeys = arrAdd(currentLoadedKeys, key);\n\n          // onLoad should trigger before internal setState to avoid `loadData` trigger twice.\n          // https://github.com/ant-design/ant-design/issues/12464\n          onLoad?.(newLoadedKeys, {\n            event: 'load',\n            node: treeNode\n          });\n          this.setUncontrolledState({\n            loadedKeys: newLoadedKeys\n          });\n          this.setState(prevState => ({\n            loadingKeys: arrDel(prevState.loadingKeys, key)\n          }));\n          resolve();\n        }).catch(e => {\n          this.setState(prevState => ({\n            loadingKeys: arrDel(prevState.loadingKeys, key)\n          }));\n\n          // If exceed max retry times, we give up retry\n          this.loadingRetryTimes[key] = (this.loadingRetryTimes[key] || 0) + 1;\n          if (this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {\n            const {\n              loadedKeys: currentLoadedKeys\n            } = this.state;\n            warning(false, 'Retry for `loadData` many times but still failed. No more retry.');\n            this.setUncontrolledState({\n              loadedKeys: arrAdd(currentLoadedKeys, key)\n            });\n            resolve();\n          }\n          reject(e);\n        });\n        return {\n          loadingKeys: arrAdd(loadingKeys, key)\n        };\n      });\n    });\n\n    // Not care warning if we ignore this\n    loadPromise.catch(() => {});\n    return loadPromise;\n  };\n  onNodeMouseEnter = (event, node) => {\n    const {\n      onMouseEnter\n    } = this.props;\n    onMouseEnter?.({\n      event,\n      node\n    });\n  };\n  onNodeMouseLeave = (event, node) => {\n    const {\n      onMouseLeave\n    } = this.props;\n    onMouseLeave?.({\n      event,\n      node\n    });\n  };\n  onNodeContextMenu = (event, node) => {\n    const {\n      onRightClick\n    } = this.props;\n    if (onRightClick) {\n      event.preventDefault();\n      onRightClick({\n        event,\n        node\n      });\n    }\n  };\n  onFocus = (...args) => {\n    const {\n      onFocus,\n      disabled\n    } = this.props;\n    const {\n      activeKey,\n      selectedKeys,\n      flattenNodes\n    } = this.state;\n    if (!disabled && activeKey === null) {\n      const visibleSelectedKey = selectedKeys.find(key => {\n        return flattenNodes.some(nodeItem => nodeItem.key === key);\n      });\n      if (visibleSelectedKey !== undefined) {\n        this.onActiveChange(visibleSelectedKey);\n      } else {\n        this.onActiveChange(flattenNodes?.[0]?.key || null);\n      }\n    }\n    onFocus?.(...args);\n  };\n  onBlur = (...args) => {\n    const {\n      onBlur\n    } = this.props;\n    this.onActiveChange(null);\n    onBlur?.(...args);\n  };\n  getTreeNodeRequiredProps = () => {\n    const {\n      expandedKeys,\n      selectedKeys,\n      loadedKeys,\n      loadingKeys,\n      checkedKeys,\n      halfCheckedKeys,\n      dragOverNodeKey,\n      dropPosition,\n      keyEntities\n    } = this.state;\n    return {\n      expandedKeys: expandedKeys || [],\n      selectedKeys: selectedKeys || [],\n      loadedKeys: loadedKeys || [],\n      loadingKeys: loadingKeys || [],\n      checkedKeys: checkedKeys || [],\n      halfCheckedKeys: halfCheckedKeys || [],\n      dragOverNodeKey,\n      dropPosition,\n      keyEntities: keyEntities\n    };\n  };\n\n  // =========================== Expanded ===========================\n  /** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */\n  setExpandedKeys = expandedKeys => {\n    const {\n      treeData,\n      fieldNames\n    } = this.state;\n    const flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);\n    this.setUncontrolledState({\n      expandedKeys,\n      flattenNodes\n    }, true);\n  };\n  onNodeExpand = (e, treeNode) => {\n    let {\n      expandedKeys\n    } = this.state;\n    const {\n      listChanging,\n      fieldNames\n    } = this.state;\n    const {\n      onExpand,\n      loadData\n    } = this.props;\n    const {\n      expanded\n    } = treeNode;\n    const key = treeNode[fieldNames.key];\n\n    // Do nothing when motion is in progress\n    if (listChanging) {\n      return;\n    }\n\n    // Update selected keys\n    const certain = expandedKeys.includes(key);\n    const targetExpanded = !expanded;\n    warning(expanded && certain || !expanded && !certain, 'Expand state not sync with index check');\n    expandedKeys = targetExpanded ? arrAdd(expandedKeys, key) : arrDel(expandedKeys, key);\n    this.setExpandedKeys(expandedKeys);\n    onExpand?.(expandedKeys, {\n      node: treeNode,\n      expanded: targetExpanded,\n      nativeEvent: e.nativeEvent\n    });\n\n    // Async Load data\n    if (targetExpanded && loadData) {\n      const loadPromise = this.onNodeLoad(treeNode);\n      if (loadPromise) {\n        loadPromise.then(() => {\n          // [Legacy] Refresh logic\n          const newFlattenTreeData = flattenTreeData(this.state.treeData, expandedKeys, fieldNames);\n          this.setUncontrolledState({\n            flattenNodes: newFlattenTreeData\n          });\n        }).catch(() => {\n          const {\n            expandedKeys: currentExpandedKeys\n          } = this.state;\n          const expandedKeysToRestore = arrDel(currentExpandedKeys, key);\n          this.setExpandedKeys(expandedKeysToRestore);\n        });\n      }\n    }\n  };\n  onListChangeStart = () => {\n    this.setUncontrolledState({\n      listChanging: true\n    });\n  };\n  onListChangeEnd = () => {\n    setTimeout(() => {\n      this.setUncontrolledState({\n        listChanging: false\n      });\n    });\n  };\n\n  // =========================== Keyboard ===========================\n  onActiveChange = newActiveKey => {\n    const {\n      activeKey\n    } = this.state;\n    const {\n      onActiveChange,\n      itemScrollOffset = 0\n    } = this.props;\n    if (activeKey === newActiveKey) {\n      return;\n    }\n    this.setState({\n      activeKey: newActiveKey\n    });\n    if (newActiveKey !== null) {\n      this.scrollTo({\n        key: newActiveKey,\n        offset: itemScrollOffset\n      });\n    }\n    onActiveChange?.(newActiveKey);\n  };\n  getActiveItem = () => {\n    const {\n      activeKey,\n      flattenNodes\n    } = this.state;\n    if (activeKey === null) {\n      return null;\n    }\n    return flattenNodes.find(({\n      key\n    }) => key === activeKey) || null;\n  };\n  offsetActiveKey = offset => {\n    const {\n      flattenNodes,\n      activeKey\n    } = this.state;\n    let index = flattenNodes.findIndex(({\n      key\n    }) => key === activeKey);\n\n    // Align with index\n    if (index === -1 && offset < 0) {\n      index = flattenNodes.length;\n    }\n    index = (index + offset + flattenNodes.length) % flattenNodes.length;\n    const item = flattenNodes[index];\n    if (item) {\n      const {\n        key\n      } = item;\n      this.onActiveChange(key);\n    } else {\n      this.onActiveChange(null);\n    }\n  };\n  onKeyDown = event => {\n    const {\n      activeKey,\n      expandedKeys,\n      checkedKeys,\n      flattenNodes,\n      keyEntities\n    } = this.state;\n    const {\n      onKeyDown,\n      checkable,\n      selectable,\n      disabled,\n      loadData\n    } = this.props;\n    if (disabled) {\n      return;\n    }\n\n    // >>>>>>>>>> Direction\n    switch (event.key) {\n      case 'ArrowUp':\n        {\n          this.offsetActiveKey(-1);\n          event.preventDefault();\n          break;\n        }\n      case 'ArrowDown':\n        {\n          this.offsetActiveKey(1);\n          event.preventDefault();\n          break;\n        }\n      case 'Home':\n        {\n          this.onActiveChange(flattenNodes?.[0]?.key);\n          event.preventDefault();\n          break;\n        }\n      case 'End':\n        {\n          this.onActiveChange(flattenNodes?.[flattenNodes.length - 1]?.key);\n          event.preventDefault();\n          break;\n        }\n    }\n\n    // >>>>>>>>>> Expand & Selection\n    const activeItem = this.getActiveItem();\n    if (activeItem && activeItem.data) {\n      const treeNodeRequiredProps = this.getTreeNodeRequiredProps();\n      const eventNode = convertNodePropsToEventData({\n        ...getTreeNodeProps(activeKey, treeNodeRequiredProps),\n        data: activeItem.data,\n        active: true\n      });\n      const entity = getEntity(keyEntities, activeKey);\n      const hasChildren = !!entity?.children?.length;\n      const expandable = !isLeafNode(activeItem.data.isLeaf, loadData, hasChildren, eventNode.loaded);\n      const canCheck = checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox;\n      const canSelect = !checkable && selectable && !eventNode.disabled && eventNode.selectable !== false;\n      switch (event.key) {\n        // >>> Expand\n        case 'ArrowLeft':\n          {\n            // Collapse if possible\n            if (expandable && expandedKeys.includes(activeKey)) {\n              this.onNodeExpand({}, eventNode);\n            } else if (activeItem.parent) {\n              this.onActiveChange(activeItem.parent.key);\n            }\n            event.preventDefault();\n            break;\n          }\n        case 'ArrowRight':\n          {\n            // Expand if possible\n            if (expandable && !expandedKeys.includes(activeKey)) {\n              this.onNodeExpand({}, eventNode);\n            } else if (activeItem.children && activeItem.children.length) {\n              this.onActiveChange(activeItem.children[0].key);\n            }\n            event.preventDefault();\n            break;\n          }\n        case 'Enter':\n          {\n            if (expandable) {\n              event.preventDefault();\n              this.onNodeExpand({}, eventNode);\n            } else if (canCheck) {\n              if (!checkedKeys.includes(activeKey)) {\n                event.preventDefault();\n                this.onNodeCheck({}, eventNode, true);\n              }\n            } else if (canSelect && !eventNode.selected) {\n              event.preventDefault();\n              this.onNodeSelect({}, eventNode);\n            }\n            break;\n          }\n        case ' ':\n          {\n            if (canCheck) {\n              event.preventDefault();\n              this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));\n            } else if (canSelect) {\n              event.preventDefault();\n              this.onNodeSelect({}, eventNode);\n            }\n            break;\n          }\n      }\n    }\n    onKeyDown?.(event);\n  };\n\n  /**\n   * Only update the value which is not in props\n   */\n  setUncontrolledState = (state, atomic = false, forceState = null) => {\n    if (!this.destroyed) {\n      let needSync = false;\n      let allPassed = true;\n      const newState = {};\n      Object.keys(state).forEach(name => {\n        if (this.props.hasOwnProperty(name)) {\n          allPassed = false;\n          return;\n        }\n        needSync = true;\n        newState[name] = state[name];\n      });\n      if (needSync && (!atomic || allPassed)) {\n        this.setState({\n          ...newState,\n          ...forceState\n        });\n      }\n    }\n  };\n  scrollTo = scroll => {\n    this.listRef.current.scrollTo(scroll);\n  };\n  render() {\n    const {\n      flattenNodes,\n      keyEntities,\n      draggingNodeKey,\n      dropLevelOffset,\n      dropContainerKey,\n      dropTargetKey,\n      dropPosition,\n      dragOverNodeKey,\n      indent\n    } = this.state;\n    const {\n      prefixCls,\n      className,\n      style,\n      styles,\n      classNames: treeClassNames,\n      showLine,\n      focusable,\n      tabIndex = 0,\n      selectable,\n      showIcon,\n      icon,\n      switcherIcon,\n      draggable,\n      checkable,\n      checkStrictly,\n      disabled,\n      motion,\n      loadData,\n      filterTreeNode,\n      height,\n      itemHeight,\n      scrollWidth,\n      virtual,\n      titleRender,\n      dropIndicatorRender,\n      onContextMenu,\n      onScroll,\n      direction,\n      rootClassName,\n      rootStyle\n    } = this.props;\n    const domProps = pickAttrs(this.props, {\n      aria: true,\n      data: true\n    });\n\n    // It's better move to hooks but we just simply keep here\n    let draggableConfig;\n    if (draggable) {\n      if (typeof draggable === 'object') {\n        draggableConfig = draggable;\n      } else if (typeof draggable === 'function') {\n        draggableConfig = {\n          nodeDraggable: draggable\n        };\n      } else {\n        draggableConfig = {};\n      }\n    }\n    const contextValue = {\n      styles,\n      classNames: treeClassNames,\n      prefixCls,\n      selectable,\n      showIcon,\n      icon,\n      switcherIcon,\n      draggable: draggableConfig,\n      draggingNodeKey,\n      checkable,\n      checkStrictly,\n      disabled,\n      keyEntities,\n      dropLevelOffset,\n      dropContainerKey,\n      dropTargetKey,\n      dropPosition,\n      dragOverNodeKey,\n      indent,\n      direction,\n      dropIndicatorRender,\n      loadData,\n      filterTreeNode,\n      titleRender,\n      onNodeClick: this.onNodeClick,\n      onNodeDoubleClick: this.onNodeDoubleClick,\n      onNodeExpand: this.onNodeExpand,\n      onNodeSelect: this.onNodeSelect,\n      onNodeCheck: this.onNodeCheck,\n      onNodeLoad: this.onNodeLoad,\n      onNodeMouseEnter: this.onNodeMouseEnter,\n      onNodeMouseLeave: this.onNodeMouseLeave,\n      onNodeContextMenu: this.onNodeContextMenu,\n      onNodeDragStart: this.onNodeDragStart,\n      onNodeDragEnter: this.onNodeDragEnter,\n      onNodeDragOver: this.onNodeDragOver,\n      onNodeDragLeave: this.onNodeDragLeave,\n      onNodeDragEnd: this.onNodeDragEnd,\n      onNodeDrop: this.onNodeDrop\n    };\n    return /*#__PURE__*/React.createElement(TreeContext.Provider, {\n      value: contextValue\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: clsx(prefixCls, className, rootClassName, {\n        [`${prefixCls}-show-line`]: showLine\n      }),\n      style: rootStyle\n    }, /*#__PURE__*/React.createElement(NodeList, _extends({\n      ref: this.listRef,\n      prefixCls: prefixCls,\n      style: style,\n      data: flattenNodes,\n      disabled: disabled,\n      selectable: selectable,\n      checkable: !!checkable,\n      motion: motion,\n      dragging: draggingNodeKey !== null,\n      height: height,\n      itemHeight: itemHeight,\n      virtual: virtual,\n      focusable: focusable,\n      tabIndex: tabIndex,\n      activeItem: this.getActiveItem(),\n      onFocus: this.onFocus,\n      onBlur: this.onBlur,\n      onKeyDown: this.onKeyDown,\n      onActiveChange: this.onActiveChange,\n      onListChangeStart: this.onListChangeStart,\n      onListChangeEnd: this.onListChangeEnd,\n      onContextMenu: onContextMenu,\n      onScroll: onScroll,\n      scrollWidth: scrollWidth\n    }, this.getTreeNodeRequiredProps(), domProps))));\n  }\n}\nexport default Tree;","map":{"version":3,"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","clsx","pickAttrs","warning","React","TreeContext","DropIndicator","NodeList","MOTION_KEY","MotionEntity","TreeNode","arrAdd","arrDel","calcDropPosition","calcSelectedKeys","conductExpandParent","getDragChildrenKeys","parseCheckedKeys","posToArr","conductCheck","getEntity","convertDataToEntities","convertNodePropsToEventData","convertTreeToData","fillFieldNames","flattenTreeData","getTreeNodeProps","isLeafNode","warningWithoutKey","MAX_RETRY_TIMES","Tree","Component","defaultProps","prefixCls","showLine","showIcon","selectable","multiple","checkable","disabled","checkStrictly","draggable","defaultExpandParent","autoExpandParent","defaultExpandAll","defaultExpandedKeys","defaultCheckedKeys","defaultSelectedKeys","dropIndicatorRender","allowDrop","expandAction","destroyed","delayedDragEnterLogic","loadingRetryTimes","state","keyEntities","indent","selectedKeys","checkedKeys","halfCheckedKeys","loadedKeys","loadingKeys","expandedKeys","draggingNodeKey","dragChildrenKeys","dropTargetKey","dropPosition","dropContainerKey","dropLevelOffset","dropTargetPos","dropAllowed","dragOverNodeKey","treeData","flattenNodes","activeKey","listChanging","prevProps","fieldNames","dragStartMousePosition","dragNodeProps","currentMouseOverDroppableNodeKey","listRef","createRef","componentDidMount","onUpdated","componentDidUpdate","itemScrollOffset","props","undefined","setState","scrollTo","offset","componentWillUnmount","window","removeEventListener","onWindowDragEnd","getDerivedStateFromProps","prevState","newState","needSync","name","children","entitiesMap","process","env","NODE_ENV","cloneKeyEntities","nextExpandedKeys","keys","forEach","entity","push","checkedKeyEntity","conductKeys","onNodeDragStart","event","nodeProps","onDragStart","eventKey","x","clientX","y","clientY","newExpandedKeys","current","getIndentWidth","setExpandedKeys","addEventListener","node","onNodeDragEnter","onDragEnter","onExpand","direction","pos","resetDragState","includes","clearTimeout","persist","setTimeout","expanded","nativeEvent","onNodeDragOver","onDragOver","onNodeDragLeave","currentTarget","contains","relatedTarget","onDragLeave","onNodeDragEnd","onDragEnd","cleanDragState","onNodeDrop","_","outsideTree","onDrop","abstractDropNodeProps","getTreeNodeRequiredProps","active","getActiveItem","data","dropToChild","posArr","dropResult","dragNode","dragNodesKeys","concat","dropToGap","Number","triggerExpandActionExpand","e","treeNode","isLeaf","shiftKey","metaKey","ctrlKey","filter","nodeItem","eventNode","onNodeExpand","onNodeClick","onClick","onNodeDoubleClick","onDoubleClick","onNodeSelect","onSelect","selected","targetSelected","selectedNodes","map","selectedKey","Boolean","setUncontrolledState","onNodeCheck","checked","oriCheckedKeys","oriHalfCheckedKeys","onCheck","checkedObj","eventObj","halfChecked","checkedNodes","checkedKey","keySet","Set","delete","Array","from","checkedNodesPositions","onNodeLoad","loadPromise","Promise","resolve","reject","loadData","onLoad","promise","then","currentLoadedKeys","newLoadedKeys","catch","onNodeMouseEnter","onMouseEnter","onNodeMouseLeave","onMouseLeave","onNodeContextMenu","onRightClick","preventDefault","onFocus","args","visibleSelectedKey","find","some","onActiveChange","onBlur","certain","targetExpanded","newFlattenTreeData","currentExpandedKeys","expandedKeysToRestore","onListChangeStart","onListChangeEnd","newActiveKey","offsetActiveKey","index","findIndex","item","onKeyDown","activeItem","treeNodeRequiredProps","hasChildren","expandable","loaded","canCheck","disableCheckbox","canSelect","parent","atomic","forceState","allPassed","scroll","render","className","style","styles","classNames","treeClassNames","focusable","tabIndex","icon","switcherIcon","motion","filterTreeNode","height","itemHeight","scrollWidth","virtual","titleRender","onContextMenu","onScroll","rootClassName","rootStyle","domProps","aria","draggableConfig","nodeDraggable","contextValue","createElement","Provider","value","ref","dragging"],"sources":["D:/ZSM/beachboys-concert/frontend/node_modules/@rc-component/tree/es/Tree.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n// TODO: Fully accessibility support\n// Reference: https://www.w3.org/WAI/ARIA/apg/patterns/treeview\n\nimport { clsx } from 'clsx';\nimport pickAttrs from \"@rc-component/util/es/pickAttrs\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { TreeContext } from \"./contextTypes\";\nimport DropIndicator from \"./DropIndicator\";\nimport NodeList, { MOTION_KEY, MotionEntity } from \"./NodeList\";\nimport TreeNode from \"./TreeNode\";\nimport { arrAdd, arrDel, calcDropPosition, calcSelectedKeys, conductExpandParent, getDragChildrenKeys, parseCheckedKeys, posToArr } from \"./util\";\nimport { conductCheck } from \"./utils/conductUtil\";\nimport getEntity from \"./utils/keyUtil\";\nimport { convertDataToEntities, convertNodePropsToEventData, convertTreeToData, fillFieldNames, flattenTreeData, getTreeNodeProps, isLeafNode, warningWithoutKey } from \"./utils/treeUtil\";\nconst MAX_RETRY_TIMES = 10;\nclass Tree extends React.Component {\n  static defaultProps = {\n    prefixCls: 'rc-tree',\n    showLine: false,\n    showIcon: true,\n    selectable: true,\n    multiple: false,\n    checkable: false,\n    disabled: false,\n    checkStrictly: false,\n    draggable: false,\n    defaultExpandParent: true,\n    autoExpandParent: false,\n    defaultExpandAll: false,\n    defaultExpandedKeys: [],\n    defaultCheckedKeys: [],\n    defaultSelectedKeys: [],\n    dropIndicatorRender: DropIndicator,\n    allowDrop: () => true,\n    expandAction: false\n  };\n  static TreeNode = TreeNode;\n  destroyed = false;\n  delayedDragEnterLogic;\n  loadingRetryTimes = {};\n  state = {\n    keyEntities: {},\n    indent: null,\n    selectedKeys: [],\n    checkedKeys: [],\n    halfCheckedKeys: [],\n    loadedKeys: [],\n    loadingKeys: [],\n    expandedKeys: [],\n    draggingNodeKey: null,\n    dragChildrenKeys: [],\n    // dropTargetKey is the key of abstract-drop-node\n    // the abstract-drop-node is the real drop node when drag and drop\n    // not the DOM drag over node\n    dropTargetKey: null,\n    dropPosition: null,\n    // the drop position of abstract-drop-node, inside 0, top -1, bottom 1\n    dropContainerKey: null,\n    // the container key of abstract-drop-node if dropPosition is -1 or 1\n    dropLevelOffset: null,\n    // the drop level offset of abstract-drag-over-node\n    dropTargetPos: null,\n    // the pos of abstract-drop-node\n    dropAllowed: true,\n    // if drop to abstract-drop-node is allowed\n    // the abstract-drag-over-node\n    // if mouse is on the bottom of top dom node or no the top of the bottom dom node\n    // abstract-drag-over-node is the top node\n    dragOverNodeKey: null,\n    treeData: [],\n    flattenNodes: [],\n    activeKey: null,\n    listChanging: false,\n    prevProps: null,\n    fieldNames: fillFieldNames()\n  };\n  dragStartMousePosition = null;\n  dragNodeProps = null;\n  currentMouseOverDroppableNodeKey = null;\n  listRef = /*#__PURE__*/React.createRef();\n  componentDidMount() {\n    this.destroyed = false;\n    this.onUpdated();\n  }\n  componentDidUpdate() {\n    this.onUpdated();\n  }\n  onUpdated() {\n    const {\n      activeKey,\n      itemScrollOffset = 0\n    } = this.props;\n    if (activeKey !== undefined && activeKey !== this.state.activeKey) {\n      this.setState({\n        activeKey\n      });\n      if (activeKey !== null) {\n        this.scrollTo({\n          key: activeKey,\n          offset: itemScrollOffset\n        });\n      }\n    }\n  }\n  componentWillUnmount() {\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n    this.destroyed = true;\n  }\n  static getDerivedStateFromProps(props, prevState) {\n    const {\n      prevProps\n    } = prevState;\n    const newState = {\n      prevProps: props\n    };\n    function needSync(name) {\n      return !prevProps && props.hasOwnProperty(name) || prevProps && prevProps[name] !== props[name];\n    }\n\n    // ================== Tree Node ==================\n    let treeData;\n\n    // fieldNames\n    let {\n      fieldNames\n    } = prevState;\n    if (needSync('fieldNames')) {\n      fieldNames = fillFieldNames(props.fieldNames);\n      newState.fieldNames = fieldNames;\n    }\n\n    // Check if `treeData` or `children` changed and save into the state.\n    if (needSync('treeData')) {\n      ({\n        treeData\n      } = props);\n    } else if (needSync('children')) {\n      warning(false, '`children` of Tree is deprecated. Please use `treeData` instead.');\n      treeData = convertTreeToData(props.children);\n    }\n\n    // Save flatten nodes info and convert `treeData` into keyEntities\n    if (treeData) {\n      newState.treeData = treeData;\n      const entitiesMap = convertDataToEntities(treeData, {\n        fieldNames\n      });\n      newState.keyEntities = {\n        [MOTION_KEY]: MotionEntity,\n        ...entitiesMap.keyEntities\n      };\n\n      // Warning if treeNode not provide key\n      if (process.env.NODE_ENV !== 'production') {\n        warningWithoutKey(treeData, fieldNames);\n      }\n    }\n    const keyEntities = newState.keyEntities || prevState.keyEntities;\n\n    // ================ expandedKeys =================\n    if (needSync('expandedKeys') || prevProps && needSync('autoExpandParent')) {\n      newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;\n    } else if (!prevProps && props.defaultExpandAll) {\n      const cloneKeyEntities = {\n        ...keyEntities\n      };\n      delete cloneKeyEntities[MOTION_KEY];\n\n      // Only take the key who has the children to enhance the performance\n      const nextExpandedKeys = [];\n      Object.keys(cloneKeyEntities).forEach(key => {\n        const entity = cloneKeyEntities[key];\n        if (entity.children && entity.children.length) {\n          nextExpandedKeys.push(entity.key);\n        }\n      });\n      newState.expandedKeys = nextExpandedKeys;\n    } else if (!prevProps && props.defaultExpandedKeys) {\n      newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;\n    }\n    if (!newState.expandedKeys) {\n      delete newState.expandedKeys;\n    }\n\n    // ================ flattenNodes =================\n    if (treeData || newState.expandedKeys) {\n      const flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);\n      newState.flattenNodes = flattenNodes;\n    }\n\n    // ================ selectedKeys =================\n    if (props.selectable) {\n      if (needSync('selectedKeys')) {\n        newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);\n      } else if (!prevProps && props.defaultSelectedKeys) {\n        newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);\n      }\n    }\n\n    // ================= checkedKeys =================\n    if (props.checkable) {\n      let checkedKeyEntity;\n      if (needSync('checkedKeys')) {\n        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};\n      } else if (!prevProps && props.defaultCheckedKeys) {\n        checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};\n      } else if (treeData) {\n        // If `treeData` changed, we also need check it\n        checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {\n          checkedKeys: prevState.checkedKeys,\n          halfCheckedKeys: prevState.halfCheckedKeys\n        };\n      }\n      if (checkedKeyEntity) {\n        let {\n          checkedKeys = [],\n          halfCheckedKeys = []\n        } = checkedKeyEntity;\n        if (!props.checkStrictly) {\n          const conductKeys = conductCheck(checkedKeys, true, keyEntities);\n          ({\n            checkedKeys,\n            halfCheckedKeys\n          } = conductKeys);\n        }\n        newState.checkedKeys = checkedKeys;\n        newState.halfCheckedKeys = halfCheckedKeys;\n      }\n    }\n\n    // ================= loadedKeys ==================\n    if (needSync('loadedKeys')) {\n      newState.loadedKeys = props.loadedKeys;\n    }\n    return newState;\n  }\n  onNodeDragStart = (event, nodeProps) => {\n    const {\n      expandedKeys,\n      keyEntities\n    } = this.state;\n    const {\n      onDragStart\n    } = this.props;\n    const {\n      eventKey\n    } = nodeProps;\n    this.dragNodeProps = nodeProps;\n    this.dragStartMousePosition = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    const newExpandedKeys = arrDel(expandedKeys, eventKey);\n    this.setState({\n      draggingNodeKey: eventKey,\n      dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),\n      indent: this.listRef.current.getIndentWidth()\n    });\n    this.setExpandedKeys(newExpandedKeys);\n    window.addEventListener('dragend', this.onWindowDragEnd);\n    onDragStart?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n\n  /**\n   * [Legacy] Select handler is smaller than node,\n   * so that this will trigger when drag enter node or select handler.\n   * This is a little tricky if customize css without padding.\n   * Better for use mouse move event to refresh drag state.\n   * But let's just keep it to avoid event trigger logic change.\n   */\n  onNodeDragEnter = (event, nodeProps) => {\n    const {\n      expandedKeys,\n      keyEntities,\n      dragChildrenKeys,\n      flattenNodes,\n      indent\n    } = this.state;\n    const {\n      onDragEnter,\n      onExpand,\n      allowDrop,\n      direction\n    } = this.props;\n    const {\n      pos,\n      eventKey\n    } = nodeProps;\n\n    // record the key of node which is latest entered, used in dragleave event.\n    if (this.currentMouseOverDroppableNodeKey !== eventKey) {\n      this.currentMouseOverDroppableNodeKey = eventKey;\n    }\n    if (!this.dragNodeProps) {\n      this.resetDragState();\n      return;\n    }\n    const {\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed,\n      dragOverNodeKey\n    } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);\n    if (\n    // don't allow drop inside its children\n    dragChildrenKeys.includes(dropTargetKey) ||\n    // don't allow drop when drop is not allowed caculated by calcDropPosition\n    !dropAllowed) {\n      this.resetDragState();\n      return;\n    }\n\n    // Side effect for delay drag\n    if (!this.delayedDragEnterLogic) {\n      this.delayedDragEnterLogic = {};\n    }\n    Object.keys(this.delayedDragEnterLogic).forEach(key => {\n      clearTimeout(this.delayedDragEnterLogic[key]);\n    });\n    if (this.dragNodeProps.eventKey !== nodeProps.eventKey) {\n      // hoist expand logic here\n      // since if logic is on the bottom\n      // it will be blocked by abstract dragover node check\n      //   => if you dragenter from top, you mouse will still be consider as in the top node\n      event.persist();\n      this.delayedDragEnterLogic[pos] = window.setTimeout(() => {\n        if (this.state.draggingNodeKey === null) {\n          return;\n        }\n        let newExpandedKeys = [...expandedKeys];\n        const entity = getEntity(keyEntities, nodeProps.eventKey);\n        if (entity && (entity.children || []).length) {\n          newExpandedKeys = arrAdd(expandedKeys, nodeProps.eventKey);\n        }\n        if (!this.props.hasOwnProperty('expandedKeys')) {\n          this.setExpandedKeys(newExpandedKeys);\n        }\n        onExpand?.(newExpandedKeys, {\n          node: convertNodePropsToEventData(nodeProps),\n          expanded: true,\n          nativeEvent: event.nativeEvent\n        });\n      }, 800);\n    }\n\n    // Skip if drag node is self\n    if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {\n      this.resetDragState();\n      return;\n    }\n\n    // Update drag over node and drag state\n    this.setState({\n      dragOverNodeKey,\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed\n    });\n    onDragEnter?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps),\n      expandedKeys\n    });\n  };\n  onNodeDragOver = (event, nodeProps) => {\n    const {\n      dragChildrenKeys,\n      flattenNodes,\n      keyEntities,\n      expandedKeys,\n      indent\n    } = this.state;\n    const {\n      onDragOver,\n      allowDrop,\n      direction\n    } = this.props;\n    if (!this.dragNodeProps) {\n      return;\n    }\n    const {\n      dropPosition,\n      dropLevelOffset,\n      dropTargetKey,\n      dropContainerKey,\n      dropTargetPos,\n      dropAllowed,\n      dragOverNodeKey\n    } = calcDropPosition(event, this.dragNodeProps, nodeProps, indent, this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction);\n    if (dragChildrenKeys.includes(dropTargetKey) || !dropAllowed) {\n      // don't allow drop inside its children\n      // don't allow drop when drop is not allowed calculated by calcDropPosition\n      return;\n    }\n\n    // Update drag position\n\n    if (this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {\n      if (!(this.state.dropPosition === null && this.state.dropLevelOffset === null && this.state.dropTargetKey === null && this.state.dropContainerKey === null && this.state.dropTargetPos === null && this.state.dropAllowed === false && this.state.dragOverNodeKey === null)) {\n        this.resetDragState();\n      }\n    } else if (!(dropPosition === this.state.dropPosition && dropLevelOffset === this.state.dropLevelOffset && dropTargetKey === this.state.dropTargetKey && dropContainerKey === this.state.dropContainerKey && dropTargetPos === this.state.dropTargetPos && dropAllowed === this.state.dropAllowed && dragOverNodeKey === this.state.dragOverNodeKey)) {\n      this.setState({\n        dropPosition,\n        dropLevelOffset,\n        dropTargetKey,\n        dropContainerKey,\n        dropTargetPos,\n        dropAllowed,\n        dragOverNodeKey\n      });\n    }\n    onDragOver?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n  onNodeDragLeave = (event, nodeProps) => {\n    // if it is outside the droppable area\n    // currentMouseOverDroppableNodeKey will be updated in dragenter event when into another droppable receiver.\n    if (this.currentMouseOverDroppableNodeKey === nodeProps.eventKey && !event.currentTarget.contains(event.relatedTarget)) {\n      this.resetDragState();\n      this.currentMouseOverDroppableNodeKey = null;\n    }\n    const {\n      onDragLeave\n    } = this.props;\n    onDragLeave?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n  };\n\n  // since stopPropagation() is called in treeNode\n  // if onWindowDrag is called, whice means state is keeped, drag state should be cleared\n  onWindowDragEnd = event => {\n    this.onNodeDragEnd(event, null, true);\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n  };\n\n  // if onNodeDragEnd is called, onWindowDragEnd won't be called since stopPropagation() is called\n  onNodeDragEnd = (event, nodeProps) => {\n    const {\n      onDragEnd\n    } = this.props;\n    this.setState({\n      dragOverNodeKey: null\n    });\n    this.cleanDragState();\n    onDragEnd?.({\n      event,\n      node: convertNodePropsToEventData(nodeProps)\n    });\n    this.dragNodeProps = null;\n    window.removeEventListener('dragend', this.onWindowDragEnd);\n  };\n  onNodeDrop = (event, _, outsideTree = false) => {\n    const {\n      dragChildrenKeys,\n      dropPosition,\n      dropTargetKey,\n      dropTargetPos,\n      dropAllowed\n    } = this.state;\n    if (!dropAllowed) {\n      return;\n    }\n    const {\n      onDrop\n    } = this.props;\n    this.setState({\n      dragOverNodeKey: null\n    });\n    this.cleanDragState();\n    if (dropTargetKey === null) return;\n    const abstractDropNodeProps = {\n      ...getTreeNodeProps(dropTargetKey, this.getTreeNodeRequiredProps()),\n      active: this.getActiveItem()?.key === dropTargetKey,\n      data: getEntity(this.state.keyEntities, dropTargetKey).node\n    };\n    const dropToChild = dragChildrenKeys.includes(dropTargetKey);\n    warning(!dropToChild, \"Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.\");\n    const posArr = posToArr(dropTargetPos);\n    const dropResult = {\n      event,\n      node: convertNodePropsToEventData(abstractDropNodeProps),\n      dragNode: this.dragNodeProps ? convertNodePropsToEventData(this.dragNodeProps) : null,\n      dragNodesKeys: [this.dragNodeProps.eventKey].concat(dragChildrenKeys),\n      dropToGap: dropPosition !== 0,\n      dropPosition: dropPosition + Number(posArr[posArr.length - 1])\n    };\n    if (!outsideTree) {\n      onDrop?.(dropResult);\n    }\n    this.dragNodeProps = null;\n  };\n  resetDragState() {\n    this.setState({\n      dragOverNodeKey: null,\n      dropPosition: null,\n      dropLevelOffset: null,\n      dropTargetKey: null,\n      dropContainerKey: null,\n      dropTargetPos: null,\n      dropAllowed: false\n    });\n  }\n  cleanDragState = () => {\n    const {\n      draggingNodeKey\n    } = this.state;\n    if (draggingNodeKey !== null) {\n      this.setState({\n        draggingNodeKey: null,\n        dropPosition: null,\n        dropContainerKey: null,\n        dropTargetKey: null,\n        dropLevelOffset: null,\n        dropAllowed: true,\n        dragOverNodeKey: null\n      });\n    }\n    this.dragStartMousePosition = null;\n    this.currentMouseOverDroppableNodeKey = null;\n  };\n  triggerExpandActionExpand = (e, treeNode) => {\n    const {\n      expandedKeys,\n      flattenNodes\n    } = this.state;\n    const {\n      expanded,\n      key,\n      isLeaf\n    } = treeNode;\n    if (isLeaf || e.shiftKey || e.metaKey || e.ctrlKey) {\n      return;\n    }\n    const node = flattenNodes.filter(nodeItem => nodeItem.key === key)[0];\n    const eventNode = convertNodePropsToEventData({\n      ...getTreeNodeProps(key, this.getTreeNodeRequiredProps()),\n      data: node.data\n    });\n    this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));\n    this.onNodeExpand(e, eventNode);\n  };\n  onNodeClick = (e, treeNode) => {\n    const {\n      onClick,\n      expandAction\n    } = this.props;\n    if (expandAction === 'click') {\n      this.triggerExpandActionExpand(e, treeNode);\n    }\n    onClick?.(e, treeNode);\n  };\n  onNodeDoubleClick = (e, treeNode) => {\n    const {\n      onDoubleClick,\n      expandAction\n    } = this.props;\n    if (expandAction === 'doubleClick') {\n      this.triggerExpandActionExpand(e, treeNode);\n    }\n    onDoubleClick?.(e, treeNode);\n  };\n  onNodeSelect = (e, treeNode) => {\n    let {\n      selectedKeys\n    } = this.state;\n    const {\n      keyEntities,\n      fieldNames\n    } = this.state;\n    const {\n      onSelect,\n      multiple\n    } = this.props;\n    const {\n      selected\n    } = treeNode;\n    const key = treeNode[fieldNames.key];\n    const targetSelected = !selected;\n\n    // Update selected keys\n    if (!targetSelected) {\n      selectedKeys = arrDel(selectedKeys, key);\n    } else if (!multiple) {\n      selectedKeys = [key];\n    } else {\n      selectedKeys = arrAdd(selectedKeys, key);\n    }\n\n    // [Legacy] Not found related usage in doc or upper libs\n    const selectedNodes = selectedKeys.map(selectedKey => {\n      const entity = getEntity(keyEntities, selectedKey);\n      return entity ? entity.node : null;\n    }).filter(Boolean);\n    this.setUncontrolledState({\n      selectedKeys\n    });\n    onSelect?.(selectedKeys, {\n      event: 'select',\n      selected: targetSelected,\n      node: treeNode,\n      selectedNodes,\n      nativeEvent: e.nativeEvent\n    });\n  };\n  onNodeCheck = (e, treeNode, checked) => {\n    const {\n      keyEntities,\n      checkedKeys: oriCheckedKeys,\n      halfCheckedKeys: oriHalfCheckedKeys\n    } = this.state;\n    const {\n      checkStrictly,\n      onCheck\n    } = this.props;\n    const {\n      key\n    } = treeNode;\n\n    // Prepare trigger arguments\n    let checkedObj;\n    const eventObj = {\n      event: 'check',\n      node: treeNode,\n      checked,\n      nativeEvent: e.nativeEvent\n    };\n    if (checkStrictly) {\n      const checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);\n      const halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);\n      checkedObj = {\n        checked: checkedKeys,\n        halfChecked: halfCheckedKeys\n      };\n      eventObj.checkedNodes = checkedKeys.map(checkedKey => getEntity(keyEntities, checkedKey)).filter(Boolean).map(entity => entity.node);\n      this.setUncontrolledState({\n        checkedKeys\n      });\n    } else {\n      // Always fill first\n      let {\n        checkedKeys,\n        halfCheckedKeys\n      } = conductCheck([...oriCheckedKeys, key], true, keyEntities);\n\n      // If remove, we do it again to correction\n      if (!checked) {\n        const keySet = new Set(checkedKeys);\n        keySet.delete(key);\n        ({\n          checkedKeys,\n          halfCheckedKeys\n        } = conductCheck(Array.from(keySet), {\n          checked: false,\n          halfCheckedKeys\n        }, keyEntities));\n      }\n      checkedObj = checkedKeys;\n\n      // [Legacy] This is used for `rc-tree-select`\n      eventObj.checkedNodes = [];\n      eventObj.checkedNodesPositions = [];\n      eventObj.halfCheckedKeys = halfCheckedKeys;\n      checkedKeys.forEach(checkedKey => {\n        const entity = getEntity(keyEntities, checkedKey);\n        if (!entity) return;\n        const {\n          node,\n          pos\n        } = entity;\n        eventObj.checkedNodes.push(node);\n        eventObj.checkedNodesPositions.push({\n          node,\n          pos\n        });\n      });\n      this.setUncontrolledState({\n        checkedKeys\n      }, false, {\n        halfCheckedKeys\n      });\n    }\n    onCheck?.(checkedObj, eventObj);\n  };\n  onNodeLoad = treeNode => {\n    const {\n      key\n    } = treeNode;\n    const {\n      keyEntities\n    } = this.state;\n\n    // Skip if has children already\n    const entity = getEntity(keyEntities, key);\n    if (entity?.children?.length) {\n      return;\n    }\n    const loadPromise = new Promise((resolve, reject) => {\n      // We need to get the latest state of loading/loaded keys\n      this.setState(({\n        loadedKeys = [],\n        loadingKeys = []\n      }) => {\n        const {\n          loadData,\n          onLoad\n        } = this.props;\n        if (!loadData || loadedKeys.includes(key) || loadingKeys.includes(key)) {\n          return null;\n        }\n\n        // Process load data\n        const promise = loadData(treeNode);\n        promise.then(() => {\n          const {\n            loadedKeys: currentLoadedKeys\n          } = this.state;\n          const newLoadedKeys = arrAdd(currentLoadedKeys, key);\n\n          // onLoad should trigger before internal setState to avoid `loadData` trigger twice.\n          // https://github.com/ant-design/ant-design/issues/12464\n          onLoad?.(newLoadedKeys, {\n            event: 'load',\n            node: treeNode\n          });\n          this.setUncontrolledState({\n            loadedKeys: newLoadedKeys\n          });\n          this.setState(prevState => ({\n            loadingKeys: arrDel(prevState.loadingKeys, key)\n          }));\n          resolve();\n        }).catch(e => {\n          this.setState(prevState => ({\n            loadingKeys: arrDel(prevState.loadingKeys, key)\n          }));\n\n          // If exceed max retry times, we give up retry\n          this.loadingRetryTimes[key] = (this.loadingRetryTimes[key] || 0) + 1;\n          if (this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {\n            const {\n              loadedKeys: currentLoadedKeys\n            } = this.state;\n            warning(false, 'Retry for `loadData` many times but still failed. No more retry.');\n            this.setUncontrolledState({\n              loadedKeys: arrAdd(currentLoadedKeys, key)\n            });\n            resolve();\n          }\n          reject(e);\n        });\n        return {\n          loadingKeys: arrAdd(loadingKeys, key)\n        };\n      });\n    });\n\n    // Not care warning if we ignore this\n    loadPromise.catch(() => {});\n    return loadPromise;\n  };\n  onNodeMouseEnter = (event, node) => {\n    const {\n      onMouseEnter\n    } = this.props;\n    onMouseEnter?.({\n      event,\n      node\n    });\n  };\n  onNodeMouseLeave = (event, node) => {\n    const {\n      onMouseLeave\n    } = this.props;\n    onMouseLeave?.({\n      event,\n      node\n    });\n  };\n  onNodeContextMenu = (event, node) => {\n    const {\n      onRightClick\n    } = this.props;\n    if (onRightClick) {\n      event.preventDefault();\n      onRightClick({\n        event,\n        node\n      });\n    }\n  };\n  onFocus = (...args) => {\n    const {\n      onFocus,\n      disabled\n    } = this.props;\n    const {\n      activeKey,\n      selectedKeys,\n      flattenNodes\n    } = this.state;\n    if (!disabled && activeKey === null) {\n      const visibleSelectedKey = selectedKeys.find(key => {\n        return flattenNodes.some(nodeItem => nodeItem.key === key);\n      });\n      if (visibleSelectedKey !== undefined) {\n        this.onActiveChange(visibleSelectedKey);\n      } else {\n        this.onActiveChange(flattenNodes?.[0]?.key || null);\n      }\n    }\n    onFocus?.(...args);\n  };\n  onBlur = (...args) => {\n    const {\n      onBlur\n    } = this.props;\n    this.onActiveChange(null);\n    onBlur?.(...args);\n  };\n  getTreeNodeRequiredProps = () => {\n    const {\n      expandedKeys,\n      selectedKeys,\n      loadedKeys,\n      loadingKeys,\n      checkedKeys,\n      halfCheckedKeys,\n      dragOverNodeKey,\n      dropPosition,\n      keyEntities\n    } = this.state;\n    return {\n      expandedKeys: expandedKeys || [],\n      selectedKeys: selectedKeys || [],\n      loadedKeys: loadedKeys || [],\n      loadingKeys: loadingKeys || [],\n      checkedKeys: checkedKeys || [],\n      halfCheckedKeys: halfCheckedKeys || [],\n      dragOverNodeKey,\n      dropPosition,\n      keyEntities: keyEntities\n    };\n  };\n\n  // =========================== Expanded ===========================\n  /** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */\n  setExpandedKeys = expandedKeys => {\n    const {\n      treeData,\n      fieldNames\n    } = this.state;\n    const flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);\n    this.setUncontrolledState({\n      expandedKeys,\n      flattenNodes\n    }, true);\n  };\n  onNodeExpand = (e, treeNode) => {\n    let {\n      expandedKeys\n    } = this.state;\n    const {\n      listChanging,\n      fieldNames\n    } = this.state;\n    const {\n      onExpand,\n      loadData\n    } = this.props;\n    const {\n      expanded\n    } = treeNode;\n    const key = treeNode[fieldNames.key];\n\n    // Do nothing when motion is in progress\n    if (listChanging) {\n      return;\n    }\n\n    // Update selected keys\n    const certain = expandedKeys.includes(key);\n    const targetExpanded = !expanded;\n    warning(expanded && certain || !expanded && !certain, 'Expand state not sync with index check');\n    expandedKeys = targetExpanded ? arrAdd(expandedKeys, key) : arrDel(expandedKeys, key);\n    this.setExpandedKeys(expandedKeys);\n    onExpand?.(expandedKeys, {\n      node: treeNode,\n      expanded: targetExpanded,\n      nativeEvent: e.nativeEvent\n    });\n\n    // Async Load data\n    if (targetExpanded && loadData) {\n      const loadPromise = this.onNodeLoad(treeNode);\n      if (loadPromise) {\n        loadPromise.then(() => {\n          // [Legacy] Refresh logic\n          const newFlattenTreeData = flattenTreeData(this.state.treeData, expandedKeys, fieldNames);\n          this.setUncontrolledState({\n            flattenNodes: newFlattenTreeData\n          });\n        }).catch(() => {\n          const {\n            expandedKeys: currentExpandedKeys\n          } = this.state;\n          const expandedKeysToRestore = arrDel(currentExpandedKeys, key);\n          this.setExpandedKeys(expandedKeysToRestore);\n        });\n      }\n    }\n  };\n  onListChangeStart = () => {\n    this.setUncontrolledState({\n      listChanging: true\n    });\n  };\n  onListChangeEnd = () => {\n    setTimeout(() => {\n      this.setUncontrolledState({\n        listChanging: false\n      });\n    });\n  };\n\n  // =========================== Keyboard ===========================\n  onActiveChange = newActiveKey => {\n    const {\n      activeKey\n    } = this.state;\n    const {\n      onActiveChange,\n      itemScrollOffset = 0\n    } = this.props;\n    if (activeKey === newActiveKey) {\n      return;\n    }\n    this.setState({\n      activeKey: newActiveKey\n    });\n    if (newActiveKey !== null) {\n      this.scrollTo({\n        key: newActiveKey,\n        offset: itemScrollOffset\n      });\n    }\n    onActiveChange?.(newActiveKey);\n  };\n  getActiveItem = () => {\n    const {\n      activeKey,\n      flattenNodes\n    } = this.state;\n    if (activeKey === null) {\n      return null;\n    }\n    return flattenNodes.find(({\n      key\n    }) => key === activeKey) || null;\n  };\n  offsetActiveKey = offset => {\n    const {\n      flattenNodes,\n      activeKey\n    } = this.state;\n    let index = flattenNodes.findIndex(({\n      key\n    }) => key === activeKey);\n\n    // Align with index\n    if (index === -1 && offset < 0) {\n      index = flattenNodes.length;\n    }\n    index = (index + offset + flattenNodes.length) % flattenNodes.length;\n    const item = flattenNodes[index];\n    if (item) {\n      const {\n        key\n      } = item;\n      this.onActiveChange(key);\n    } else {\n      this.onActiveChange(null);\n    }\n  };\n  onKeyDown = event => {\n    const {\n      activeKey,\n      expandedKeys,\n      checkedKeys,\n      flattenNodes,\n      keyEntities\n    } = this.state;\n    const {\n      onKeyDown,\n      checkable,\n      selectable,\n      disabled,\n      loadData\n    } = this.props;\n    if (disabled) {\n      return;\n    }\n\n    // >>>>>>>>>> Direction\n    switch (event.key) {\n      case 'ArrowUp':\n        {\n          this.offsetActiveKey(-1);\n          event.preventDefault();\n          break;\n        }\n      case 'ArrowDown':\n        {\n          this.offsetActiveKey(1);\n          event.preventDefault();\n          break;\n        }\n      case 'Home':\n        {\n          this.onActiveChange(flattenNodes?.[0]?.key);\n          event.preventDefault();\n          break;\n        }\n      case 'End':\n        {\n          this.onActiveChange(flattenNodes?.[flattenNodes.length - 1]?.key);\n          event.preventDefault();\n          break;\n        }\n    }\n\n    // >>>>>>>>>> Expand & Selection\n    const activeItem = this.getActiveItem();\n    if (activeItem && activeItem.data) {\n      const treeNodeRequiredProps = this.getTreeNodeRequiredProps();\n      const eventNode = convertNodePropsToEventData({\n        ...getTreeNodeProps(activeKey, treeNodeRequiredProps),\n        data: activeItem.data,\n        active: true\n      });\n      const entity = getEntity(keyEntities, activeKey);\n      const hasChildren = !!entity?.children?.length;\n      const expandable = !isLeafNode(activeItem.data.isLeaf, loadData, hasChildren, eventNode.loaded);\n      const canCheck = checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox;\n      const canSelect = !checkable && selectable && !eventNode.disabled && eventNode.selectable !== false;\n      switch (event.key) {\n        // >>> Expand\n        case 'ArrowLeft':\n          {\n            // Collapse if possible\n            if (expandable && expandedKeys.includes(activeKey)) {\n              this.onNodeExpand({}, eventNode);\n            } else if (activeItem.parent) {\n              this.onActiveChange(activeItem.parent.key);\n            }\n            event.preventDefault();\n            break;\n          }\n        case 'ArrowRight':\n          {\n            // Expand if possible\n            if (expandable && !expandedKeys.includes(activeKey)) {\n              this.onNodeExpand({}, eventNode);\n            } else if (activeItem.children && activeItem.children.length) {\n              this.onActiveChange(activeItem.children[0].key);\n            }\n            event.preventDefault();\n            break;\n          }\n        case 'Enter':\n          {\n            if (expandable) {\n              event.preventDefault();\n              this.onNodeExpand({}, eventNode);\n            } else if (canCheck) {\n              if (!checkedKeys.includes(activeKey)) {\n                event.preventDefault();\n                this.onNodeCheck({}, eventNode, true);\n              }\n            } else if (canSelect && !eventNode.selected) {\n              event.preventDefault();\n              this.onNodeSelect({}, eventNode);\n            }\n            break;\n          }\n        case ' ':\n          {\n            if (canCheck) {\n              event.preventDefault();\n              this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));\n            } else if (canSelect) {\n              event.preventDefault();\n              this.onNodeSelect({}, eventNode);\n            }\n            break;\n          }\n      }\n    }\n    onKeyDown?.(event);\n  };\n\n  /**\n   * Only update the value which is not in props\n   */\n  setUncontrolledState = (state, atomic = false, forceState = null) => {\n    if (!this.destroyed) {\n      let needSync = false;\n      let allPassed = true;\n      const newState = {};\n      Object.keys(state).forEach(name => {\n        if (this.props.hasOwnProperty(name)) {\n          allPassed = false;\n          return;\n        }\n        needSync = true;\n        newState[name] = state[name];\n      });\n      if (needSync && (!atomic || allPassed)) {\n        this.setState({\n          ...newState,\n          ...forceState\n        });\n      }\n    }\n  };\n  scrollTo = scroll => {\n    this.listRef.current.scrollTo(scroll);\n  };\n  render() {\n    const {\n      flattenNodes,\n      keyEntities,\n      draggingNodeKey,\n      dropLevelOffset,\n      dropContainerKey,\n      dropTargetKey,\n      dropPosition,\n      dragOverNodeKey,\n      indent\n    } = this.state;\n    const {\n      prefixCls,\n      className,\n      style,\n      styles,\n      classNames: treeClassNames,\n      showLine,\n      focusable,\n      tabIndex = 0,\n      selectable,\n      showIcon,\n      icon,\n      switcherIcon,\n      draggable,\n      checkable,\n      checkStrictly,\n      disabled,\n      motion,\n      loadData,\n      filterTreeNode,\n      height,\n      itemHeight,\n      scrollWidth,\n      virtual,\n      titleRender,\n      dropIndicatorRender,\n      onContextMenu,\n      onScroll,\n      direction,\n      rootClassName,\n      rootStyle\n    } = this.props;\n    const domProps = pickAttrs(this.props, {\n      aria: true,\n      data: true\n    });\n\n    // It's better move to hooks but we just simply keep here\n    let draggableConfig;\n    if (draggable) {\n      if (typeof draggable === 'object') {\n        draggableConfig = draggable;\n      } else if (typeof draggable === 'function') {\n        draggableConfig = {\n          nodeDraggable: draggable\n        };\n      } else {\n        draggableConfig = {};\n      }\n    }\n    const contextValue = {\n      styles,\n      classNames: treeClassNames,\n      prefixCls,\n      selectable,\n      showIcon,\n      icon,\n      switcherIcon,\n      draggable: draggableConfig,\n      draggingNodeKey,\n      checkable,\n      checkStrictly,\n      disabled,\n      keyEntities,\n      dropLevelOffset,\n      dropContainerKey,\n      dropTargetKey,\n      dropPosition,\n      dragOverNodeKey,\n      indent,\n      direction,\n      dropIndicatorRender,\n      loadData,\n      filterTreeNode,\n      titleRender,\n      onNodeClick: this.onNodeClick,\n      onNodeDoubleClick: this.onNodeDoubleClick,\n      onNodeExpand: this.onNodeExpand,\n      onNodeSelect: this.onNodeSelect,\n      onNodeCheck: this.onNodeCheck,\n      onNodeLoad: this.onNodeLoad,\n      onNodeMouseEnter: this.onNodeMouseEnter,\n      onNodeMouseLeave: this.onNodeMouseLeave,\n      onNodeContextMenu: this.onNodeContextMenu,\n      onNodeDragStart: this.onNodeDragStart,\n      onNodeDragEnter: this.onNodeDragEnter,\n      onNodeDragOver: this.onNodeDragOver,\n      onNodeDragLeave: this.onNodeDragLeave,\n      onNodeDragEnd: this.onNodeDragEnd,\n      onNodeDrop: this.onNodeDrop\n    };\n    return /*#__PURE__*/React.createElement(TreeContext.Provider, {\n      value: contextValue\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: clsx(prefixCls, className, rootClassName, {\n        [`${prefixCls}-show-line`]: showLine\n      }),\n      style: rootStyle\n    }, /*#__PURE__*/React.createElement(NodeList, _extends({\n      ref: this.listRef,\n      prefixCls: prefixCls,\n      style: style,\n      data: flattenNodes,\n      disabled: disabled,\n      selectable: selectable,\n      checkable: !!checkable,\n      motion: motion,\n      dragging: draggingNodeKey !== null,\n      height: height,\n      itemHeight: itemHeight,\n      virtual: virtual,\n      focusable: focusable,\n      tabIndex: tabIndex,\n      activeItem: this.getActiveItem(),\n      onFocus: this.onFocus,\n      onBlur: this.onBlur,\n      onKeyDown: this.onKeyDown,\n      onActiveChange: this.onActiveChange,\n      onListChangeStart: this.onListChangeStart,\n      onListChangeEnd: this.onListChangeEnd,\n      onContextMenu: onContextMenu,\n      onScroll: onScroll,\n      scrollWidth: scrollWidth\n    }, this.getTreeNodeRequiredProps(), domProps))));\n  }\n}\nexport default Tree;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}