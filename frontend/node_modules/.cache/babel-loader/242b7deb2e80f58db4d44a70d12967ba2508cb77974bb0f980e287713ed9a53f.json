{"ast":null,"code":"import { useEffect } from 'react';\nimport isVisible from \"./isVisible\";\nimport useId from \"../hooks/useId\";\nfunction focusable(node, includePositive = false) {\n  if (isVisible(node)) {\n    const nodeName = node.nodeName.toLowerCase();\n    const isFocusableElement =\n    // Focusable element\n    ['input', 'select', 'textarea', 'button'].includes(nodeName) ||\n    // Editable element\n    node.isContentEditable ||\n    // Anchor with href element\n    nodeName === 'a' && !!node.getAttribute('href');\n\n    // Get tabIndex\n    const tabIndexAttr = node.getAttribute('tabindex');\n    const tabIndexNum = Number(tabIndexAttr);\n\n    // Parse as number if validate\n    let tabIndex = null;\n    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {\n      tabIndex = tabIndexNum;\n    } else if (isFocusableElement && tabIndex === null) {\n      tabIndex = 0;\n    }\n\n    // Block focusable if disabled\n    if (isFocusableElement && node.disabled) {\n      tabIndex = null;\n    }\n    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);\n  }\n  return false;\n}\nexport function getFocusNodeList(node, includePositive = false) {\n  const res = [...node.querySelectorAll('*')].filter(child => {\n    return focusable(child, includePositive);\n  });\n  if (focusable(node, includePositive)) {\n    res.unshift(node);\n  }\n  return res;\n}\n// Used for `rc-input` `rc-textarea` `rc-input-number`\n/**\n * Focus element and set cursor position for input/textarea elements.\n */\nexport function triggerFocus(element, option) {\n  if (!element) return;\n  element.focus(option);\n\n  // Selection content\n  const {\n    cursor\n  } = option || {};\n  if (cursor && (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement)) {\n    const len = element.value.length;\n    switch (cursor) {\n      case 'start':\n        element.setSelectionRange(0, 0);\n        break;\n      case 'end':\n        element.setSelectionRange(len, len);\n        break;\n      default:\n        element.setSelectionRange(0, len);\n    }\n  }\n}\n\n// ======================================================\n// ==                    Lock Focus                    ==\n// ======================================================\nlet lastFocusElement = null;\nlet focusElements = [];\n// Map stable ID to lock element\nconst idToElementMap = new Map();\n// Map stable ID to ignored element\nconst ignoredElementMap = new Map();\nfunction getLastElement() {\n  return focusElements[focusElements.length - 1];\n}\nfunction isIgnoredElement(element) {\n  const lastElement = getLastElement();\n  if (element && lastElement) {\n    // Find the ID that maps to the last element\n    let lockId;\n    for (const [id, ele] of idToElementMap.entries()) {\n      if (ele === lastElement) {\n        lockId = id;\n        break;\n      }\n    }\n    const ignoredEle = ignoredElementMap.get(lockId);\n    return !!ignoredEle && (ignoredEle === element || ignoredEle.contains(element));\n  }\n  return false;\n}\nfunction hasFocus(element) {\n  const {\n    activeElement\n  } = document;\n  return element === activeElement || element.contains(activeElement);\n}\nfunction syncFocus() {\n  const lastElement = getLastElement();\n  const {\n    activeElement\n  } = document;\n\n  // If current focus is on an ignored element, don't force it back\n  if (isIgnoredElement(activeElement)) {\n    return;\n  }\n  if (lastElement && !hasFocus(lastElement)) {\n    const focusableList = getFocusNodeList(lastElement);\n    const matchElement = focusableList.includes(lastFocusElement) ? lastFocusElement : focusableList[0];\n    matchElement?.focus({\n      preventScroll: true\n    });\n  } else {\n    lastFocusElement = activeElement;\n  }\n}\nfunction onWindowKeyDown(e) {\n  if (e.key === 'Tab') {\n    const {\n      activeElement\n    } = document;\n    const lastElement = getLastElement();\n    const focusableList = getFocusNodeList(lastElement);\n    const last = focusableList[focusableList.length - 1];\n    if (e.shiftKey && activeElement === focusableList[0]) {\n      // Tab backward on first focusable element\n      lastFocusElement = last;\n    } else if (!e.shiftKey && activeElement === last) {\n      // Tab forward on last focusable element\n      lastFocusElement = focusableList[0];\n    }\n  }\n}\n\n/**\n * Lock focus in the element.\n * It will force back to the first focusable element when focus leaves the element.\n * @param id - A stable ID for this lock instance\n */\nexport function lockFocus(element, id) {\n  if (element) {\n    // Store the mapping between ID and element\n    idToElementMap.set(id, element);\n\n    // Refresh focus elements\n    focusElements = focusElements.filter(ele => ele !== element);\n    focusElements.push(element);\n\n    // Just add event since it will de-duplicate\n    window.addEventListener('focusin', syncFocus);\n    window.addEventListener('keydown', onWindowKeyDown, true);\n    syncFocus();\n  }\n\n  // Always return unregister function\n  return () => {\n    lastFocusElement = null;\n    focusElements = focusElements.filter(ele => ele !== element);\n    idToElementMap.delete(id);\n    ignoredElementMap.delete(id);\n    if (focusElements.length === 0) {\n      window.removeEventListener('focusin', syncFocus);\n      window.removeEventListener('keydown', onWindowKeyDown, true);\n    }\n  };\n}\n\n/**\n * Lock focus within an element.\n * When locked, focus will be restricted to focusable elements within the specified element.\n * If multiple elements are locked, only the last locked element will be effective.\n * @returns A function to mark an element as ignored, which will temporarily allow focus on that element even if it's outside the locked area.\n */\nexport function useLockFocus(lock, getElement) {\n  const id = useId();\n  useEffect(() => {\n    if (lock) {\n      const element = getElement();\n      if (element) {\n        return lockFocus(element, id);\n      }\n    }\n  }, [lock, id]);\n  const ignoreElement = ele => {\n    if (ele) {\n      // Set the ignored element using stable ID\n      ignoredElementMap.set(id, ele);\n    }\n  };\n  return [ignoreElement];\n}","map":{"version":3,"names":["useEffect","isVisible","useId","focusable","node","includePositive","nodeName","toLowerCase","isFocusableElement","includes","isContentEditable","getAttribute","tabIndexAttr","tabIndexNum","Number","tabIndex","isNaN","disabled","getFocusNodeList","res","querySelectorAll","filter","child","unshift","triggerFocus","element","option","focus","cursor","HTMLInputElement","HTMLTextAreaElement","len","value","length","setSelectionRange","lastFocusElement","focusElements","idToElementMap","Map","ignoredElementMap","getLastElement","isIgnoredElement","lastElement","lockId","id","ele","entries","ignoredEle","get","contains","hasFocus","activeElement","document","syncFocus","focusableList","matchElement","preventScroll","onWindowKeyDown","e","key","last","shiftKey","lockFocus","set","push","window","addEventListener","delete","removeEventListener","useLockFocus","lock","getElement","ignoreElement"],"sources":["D:/ZSM/beachboys-concert/frontend/node_modules/@rc-component/util/es/Dom/focus.js"],"sourcesContent":["import { useEffect } from 'react';\nimport isVisible from \"./isVisible\";\nimport useId from \"../hooks/useId\";\nfunction focusable(node, includePositive = false) {\n  if (isVisible(node)) {\n    const nodeName = node.nodeName.toLowerCase();\n    const isFocusableElement =\n    // Focusable element\n    ['input', 'select', 'textarea', 'button'].includes(nodeName) ||\n    // Editable element\n    node.isContentEditable ||\n    // Anchor with href element\n    nodeName === 'a' && !!node.getAttribute('href');\n\n    // Get tabIndex\n    const tabIndexAttr = node.getAttribute('tabindex');\n    const tabIndexNum = Number(tabIndexAttr);\n\n    // Parse as number if validate\n    let tabIndex = null;\n    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {\n      tabIndex = tabIndexNum;\n    } else if (isFocusableElement && tabIndex === null) {\n      tabIndex = 0;\n    }\n\n    // Block focusable if disabled\n    if (isFocusableElement && node.disabled) {\n      tabIndex = null;\n    }\n    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);\n  }\n  return false;\n}\nexport function getFocusNodeList(node, includePositive = false) {\n  const res = [...node.querySelectorAll('*')].filter(child => {\n    return focusable(child, includePositive);\n  });\n  if (focusable(node, includePositive)) {\n    res.unshift(node);\n  }\n  return res;\n}\n// Used for `rc-input` `rc-textarea` `rc-input-number`\n/**\n * Focus element and set cursor position for input/textarea elements.\n */\nexport function triggerFocus(element, option) {\n  if (!element) return;\n  element.focus(option);\n\n  // Selection content\n  const {\n    cursor\n  } = option || {};\n  if (cursor && (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement)) {\n    const len = element.value.length;\n    switch (cursor) {\n      case 'start':\n        element.setSelectionRange(0, 0);\n        break;\n      case 'end':\n        element.setSelectionRange(len, len);\n        break;\n      default:\n        element.setSelectionRange(0, len);\n    }\n  }\n}\n\n// ======================================================\n// ==                    Lock Focus                    ==\n// ======================================================\nlet lastFocusElement = null;\nlet focusElements = [];\n// Map stable ID to lock element\nconst idToElementMap = new Map();\n// Map stable ID to ignored element\nconst ignoredElementMap = new Map();\nfunction getLastElement() {\n  return focusElements[focusElements.length - 1];\n}\nfunction isIgnoredElement(element) {\n  const lastElement = getLastElement();\n  if (element && lastElement) {\n    // Find the ID that maps to the last element\n    let lockId;\n    for (const [id, ele] of idToElementMap.entries()) {\n      if (ele === lastElement) {\n        lockId = id;\n        break;\n      }\n    }\n    const ignoredEle = ignoredElementMap.get(lockId);\n    return !!ignoredEle && (ignoredEle === element || ignoredEle.contains(element));\n  }\n  return false;\n}\nfunction hasFocus(element) {\n  const {\n    activeElement\n  } = document;\n  return element === activeElement || element.contains(activeElement);\n}\nfunction syncFocus() {\n  const lastElement = getLastElement();\n  const {\n    activeElement\n  } = document;\n\n  // If current focus is on an ignored element, don't force it back\n  if (isIgnoredElement(activeElement)) {\n    return;\n  }\n  if (lastElement && !hasFocus(lastElement)) {\n    const focusableList = getFocusNodeList(lastElement);\n    const matchElement = focusableList.includes(lastFocusElement) ? lastFocusElement : focusableList[0];\n    matchElement?.focus({\n      preventScroll: true\n    });\n  } else {\n    lastFocusElement = activeElement;\n  }\n}\nfunction onWindowKeyDown(e) {\n  if (e.key === 'Tab') {\n    const {\n      activeElement\n    } = document;\n    const lastElement = getLastElement();\n    const focusableList = getFocusNodeList(lastElement);\n    const last = focusableList[focusableList.length - 1];\n    if (e.shiftKey && activeElement === focusableList[0]) {\n      // Tab backward on first focusable element\n      lastFocusElement = last;\n    } else if (!e.shiftKey && activeElement === last) {\n      // Tab forward on last focusable element\n      lastFocusElement = focusableList[0];\n    }\n  }\n}\n\n/**\n * Lock focus in the element.\n * It will force back to the first focusable element when focus leaves the element.\n * @param id - A stable ID for this lock instance\n */\nexport function lockFocus(element, id) {\n  if (element) {\n    // Store the mapping between ID and element\n    idToElementMap.set(id, element);\n\n    // Refresh focus elements\n    focusElements = focusElements.filter(ele => ele !== element);\n    focusElements.push(element);\n\n    // Just add event since it will de-duplicate\n    window.addEventListener('focusin', syncFocus);\n    window.addEventListener('keydown', onWindowKeyDown, true);\n    syncFocus();\n  }\n\n  // Always return unregister function\n  return () => {\n    lastFocusElement = null;\n    focusElements = focusElements.filter(ele => ele !== element);\n    idToElementMap.delete(id);\n    ignoredElementMap.delete(id);\n    if (focusElements.length === 0) {\n      window.removeEventListener('focusin', syncFocus);\n      window.removeEventListener('keydown', onWindowKeyDown, true);\n    }\n  };\n}\n\n/**\n * Lock focus within an element.\n * When locked, focus will be restricted to focusable elements within the specified element.\n * If multiple elements are locked, only the last locked element will be effective.\n * @returns A function to mark an element as ignored, which will temporarily allow focus on that element even if it's outside the locked area.\n */\nexport function useLockFocus(lock, getElement) {\n  const id = useId();\n  useEffect(() => {\n    if (lock) {\n      const element = getElement();\n      if (element) {\n        return lockFocus(element, id);\n      }\n    }\n  }, [lock, id]);\n  const ignoreElement = ele => {\n    if (ele) {\n      // Set the ignored element using stable ID\n      ignoredElementMap.set(id, ele);\n    }\n  };\n  return [ignoreElement];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}